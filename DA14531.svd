<?xml version="1.0" encoding="ascii"?>
<!-- File naming: Dialog_D2632AA.svd -->
<!--
  Copyright (C) 2019 Dialog Semiconductor.
  This computer program includes Confidential, Proprietary Information  
  of Dialog Semiconductor. All Rights Reserved.

  Purpose: System Viewer Description (SVD) Example (Schema Version 1.3)
           This is a description of a none-existent and incomplete device
		   for demonstration purposes only.

  Generated by cmsis-svd (version 0.2), d.d. January 30, 2019 - 16:44:50
 -->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.3" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Dialog</vendor>                   				    <!-- device vendor name -->
  <vendorID>ARM</vendorID>                                        <!-- device vendor short name -->
  <name>DA14531</name>                                          <!-- name of part-->
  <series>DA1453x</series>                                         <!-- device series the device belongs to -->
  <version>1.2</version>                                          <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  <description>DA14531</description>
  <licenseText><!-- this license text will appear in header file. \n forces line breaks -->
  Copyright (C) 2019 Dialog Semiconductor.\n
  This computer program includes Confidential, Proprietary Information  \n
  of Dialog Semiconductor. All Rights Reserved.
</licenseText>
  <cpu><!-- details about the cpu embedded in the device (SVD version 1.2,  see https://www.keil.com/pack/doc/CMSIS/SVD/html/group__cpu_section__gr.html) -->
    <name>CM0plus</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    
    <nvicPrioBits>2</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
		
  </cpu>
  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
  <width>32</width>                                               <!-- bus width is 32 bits -->
  <!-- default settings implicitly inherited by subsequent sections -->
  <size>32</size>                                                 <!-- this is the default size (number of bits) of all peripherals
																																									 and register that do not define "size" themselves -->
  <access>read-write</access>                                     <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>                             <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>                               <!-- by default all 32Bits of the registers are used -->
	
  <peripherals>
	<peripheral>
	<name>adplldig</name>
	<version>1.0</version>
	<description>adplldig registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40003000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>152</size>
	<usage>registers</usage>
</addressBlock>
	<interrupt>
	<name>BLE_WAKEUP_LP</name>
	<description>Wakeup from Low Power Interrupt Request from BLE</description>
	<value>0</value>
</interrupt><interrupt>
	<name>BLE_GEN</name>
	<description>BLE Interrupt Request</description>
	<value>1</value>
</interrupt><interrupt>
	<name>UART</name>
	<description>UART Interrupt Request</description>
	<value>2</value>
</interrupt><interrupt>
	<name>UART2</name>
	<description>UART2 Interrupt Request</description>
	<value>3</value>
</interrupt><interrupt>
	<name>I2C</name>
	<description>I2C Interrupt Request</description>
	<value>4</value>
</interrupt><interrupt>
	<name>SPI</name>
	<description>SPI Interrupt Request</description>
	<value>5</value>
</interrupt><interrupt>
	<name>ADC</name>
	<description>Analog-Digital Converter Interrupt Request</description>
	<value>6</value>
</interrupt><interrupt>
	<name>KEYBRD</name>
	<description>Keyboard Interrupt Request</description>
	<value>7</value>
</interrupt><interrupt>
	<name>BLE_RF_DIAG</name>
	<description>Baseband or Radio Diagnostics Interrupt Request</description>
	<value>8</value>
</interrupt><interrupt>
	<name>RF_CAL</name>
	<description>Radio Calibration Interrupt Request</description>
	<value>9</value>
</interrupt><interrupt>
	<name>GPIO0</name>
	<description>GPIO Interrupt Request through debounce</description>
	<value>10</value>
</interrupt><interrupt>
	<name>GPIO1</name>
	<description>GPIO Interrupt Request through debounce</description>
	<value>11</value>
</interrupt><interrupt>
	<name>GPIO2</name>
	<description>GPIO Interrupt Request through debounce</description>
	<value>12</value>
</interrupt><interrupt>
	<name>GPIO3</name>
	<description>GPIO Interrupt Request through debounce</description>
	<value>13</value>
</interrupt><interrupt>
	<name>GPIO4</name>
	<description>GPIO Interrupt Request through debounce</description>
	<value>14</value>
</interrupt><interrupt>
	<name>SWTIM</name>
	<description>Software Timer (Timer0) Interrupt Request</description>
	<value>15</value>
</interrupt><interrupt>
	<name>WKUP_QUADEC</name>
	<description>Combines the WakeUp and QuadDecoder Interrupt Request</description>
	<value>16</value>
</interrupt><interrupt>
	<name>SWTIM1</name>
	<description>Software Timer (Timer1) Interrupt Request</description>
	<value>17</value>
</interrupt><interrupt>
	<name>RTC</name>
	<description>RTC Alarm Interrupt Request</description>
	<value>18</value>
</interrupt><interrupt>
	<name>DMA</name>
	<description>DMA Interrupt Request</description>
	<value>19</value>
</interrupt><interrupt>
	<name>XTAL32M_RDY</name>
	<description>XTAL32M settling Interrupt Request</description>
	<value>20</value>
</interrupt><interrupt>
	<name>RESERVED21</name>
	<description>Software Interrupt Request</description>
	<value>21</value>
</interrupt><interrupt>
	<name>RESERVED22</name>
	<description>Software Interrupt Request</description>
	<value>22</value>
</interrupt><interrupt>
	<name>RESERVED23</name>
	<description>Software Interrupt Request</description>
	<value>23</value>
</interrupt>
	<registers>
	<register>
	<name>ADPLL_ACC_CTRL_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>EN_CMF_AVG</name>
	<description>Enable CMF averaging.
0: Disabled
1: Enabled (default)</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLIP_MOD_TUNE_0_TX</name>
	<description>Clipping value for mod_tune 0 in TX mode.</description>
	<bitRange>[28:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLIP_MOD_TUNE_0_RX</name>
	<description>Clipping value for mod_tune 0 in RX mode.</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_ANATST_CTRL_REG</name>
	
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ANATSTSPARE</name>
	<description>Analog test spare outputs.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ANATSTEN</name>
	<description>Analog test enable outputs.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_ANATST_RD_REG</name>
	
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ANATSTSPARE_IN</name>
	<description>Ana test spare in.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_ANA_CTRL_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0215807b</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DTC_LDO_DMY</name>
	<description>Control signal for TDC/DTC/VPA LDO dummy loads.</description>
	<bitRange>[28:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VPASETTLE</name>
	<description>Allow TDC after an edge on VPA en
00: No
01: Rising
10: Falling
11: Both edges</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDC_OFFSET</name>
	<description>TDC offset that is to be subtracted from the binary input to obtain the signed value (default 10.5).</description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DTC_EN</name>
	<description>Enable DTC</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DTCOFFSET</name>
	<description>Offset Added to DTC output
For correct reset time requirement, DTCOFFSET must be set to 11 before initiating any radio transaction. </description>
	<bitRange>[14:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TGLDETEN</name>
	<description>Enable PHV toggle and TDC Bubble detection.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_CKDCOMOD</name>
	<description>Enable clock registering the dcomod (default = 1).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INV_CKDCOMOD</name>
	<description>Invert clock polarity of the clock registering the dcomod.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INV_CKPHV</name>
	<description>Invert clock polarity of the clock registering the variable phase accumulator.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INV_CKTDC</name>
	<description>Invert clock polarity of the clock registering the time to digital converter.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDC_INV</name>
	<description>Invert sign of the time to digital converter output.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDC_CKVIN_EN</name>
	<description>Enable ckv input of the TDC.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDC_DTCIN_EN</name>
	<description>Enable DTC input of the TDC.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_ATTR_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>PWR_MODE_TX</name>
	<description>Power mode option to be used for DCO amplitude selection in TX.
0: Low power
1: High performance (default)</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PWR_MODE_RX</name>
	<description>Power mode option to be used for DCO amplitude selection in RX.
0: Low power
1: High performance (default)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_CN_CTRL_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x09620100</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CH0</name>
	<description>Channel 0 frequency in MHz (CH0) (ufix13)
default: 2402</description>
	<bitRange>[28:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SGN</name>
	<description>Sign bit for the channel step
0: positive (default)
1: negative</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CS</name>
	<description>Channel spacing.
0: 1 MHz spacing
1: 2 MHz spacing (default)</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CN</name>
	<description>Channel number.
Default: 0</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_DCOAMP_CAL_CTRL_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x77770011</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCOAMPIC_LP_TX</name>
	<description>Initial condition for the DCO amplitude setting, for Low Power TX mode..</description>
	<bitRange>[31:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOAMPIC_LP_RX</name>
	<description>Initial condition for the DCO amplitude setting, for Low Power RX mode..</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOAMPIC_HP_TX</name>
	<description>Initial condition for the DCO amplitude setting, for High Performance TX mode..</description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOAMPIC_HP_RX</name>
	<description>Initial condition for the DCO amplitude setting, for High Performance RX mode..</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOAMPTM</name>
	<description>Time spend to perform DCO amplitude calibration
0: 1 us
1: 2 us</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AMPCALEN</name>
	<description>Enable DCO amplitude calibration.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KMEDIUM</name>
	<description>Proportional gain setting for medium tuning.</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KCOARSE</name>
	<description>Proportional gain setting for coarse tuning.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_DCO_RD_REG</name>
	
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x1c000007</resetValue>
	<resetMask>0x3fffffff</resetMask>
	<fields><field>
	<name>DCOAMP</name>
	<description>DCO amplitude setting.
The read value is the output of adplldig (towards the analog). So, the read value is even after the overruling.</description>
	<bitRange>[29:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOMOD</name>
	<description>Current state of the DCO mod capacitor bank
(signed)
The open-loop output (before the addition of modulated data). So, it is after averaging, before SDM and addition of the modulated data.</description>
	<bitRange>[25:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOFINE</name>
	<description>Current state of the DCO fine capacitor bank
(signed)
ACC outputs are read (the averaged values.)
For CMF we are reading before bin2thm conversion</description>
	<bitRange>[12:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOMEDIUM</name>
	<description>Current state of the DCO medium capacitor bank
(signed)
ACC outputs are read (the averaged values.)
For CMF we are reading before bin2thm conversion</description>
	<bitRange>[6:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOCOARSE</name>
	<description>Current state of the DCO coarse capacitor bank
(signed)
ACC outputs are read (the averaged values.)
For CMF we are reading before bin2thm conversion</description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_DIV_CTRL_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0198ff03</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXDIV_TRIM</name>
	<description>Tx divider trim value.</description>
	<bitRange>[25:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXDIV_TRIM</name>
	<description>Rx divider trim value.</description>
	<bitRange>[16:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXDIV_FB_EN_TX</name>
	<description>Enable rxdiv for FB in TX mode.
0: Disable (default)
1: Enable</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXDIV_FB_EN_RX</name>
	<description>Enable rxdiv for FB in RX mode.
0: Disable
1: Enable (default)</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FBDIV_EN</name>
	<description>Feedback divider enable
1: Enabled
0: Disabled.

If disabled both feedback and RF output clock will be disabled. This bit is intended for test purposes (not for normal usage).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_FIF_CTRL1_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000400</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FIFRX_1M</name>
	<description>IF frequency (in MHz) used in 1 Mbps RX mode
sfix(14,10) - 1 bit sign, 3 bits integer, 10 bits fractional for MHz unit.</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_FIF_CTRL2_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FIFTX</name>
	<description>IF frequency (in MHz) used in TX mode
sfix(14,10) - 1 bit sign, 3 bits integer, 10 bits fractional for MHz unit.</description>
	<bitRange>[29:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FIFRX_OFFSET</name>
	<description>Offset for the IF frequency (in MHz) in RX mode.
sfix(14,10) - 1 bit sign, 3 bits integer, 10 bits fractional for MHz unit.</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_FREQMEAS_RD_REG</name>
	
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x21000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MEASDONE_OUT</name>
	<description>Signal indicating the state of the frequency counter
0: Measuring frequency
1: Measurement done</description>
	<bitRange>[29:29]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>QUALMONDET</name>
	<description>Clock quality monitoring detector output.</description>
	<bitRange>[26:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDCBUB</name>
	<description>Detector output indicating a bubble error in the TDC input.</description>
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PHVSA0</name>
	<description>Detector output indicating a stuck-at 0 on the variable phase accumulator input .</description>
	<bitRange>[24:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PHVSA1</name>
	<description>Detector output indicating a stuck-at 1 on the variable phase accumulator input .</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQDIFF</name>
	<description>Measured frequency difference (signed).</description>
	<bitRange>[22:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_FSM_CTRL_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x08f8ae84</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TVPASETTLE</name>
	<description>Settling time required after vpa disable.</description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TSETTLE</name>
	<description>Time spend waiting for settling
0 - 15: 0 - 7.5 us (t = TSETTLE/2)</description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TPASETTLE</name>
	<description>Time spend waiting for PA to settle
0 - 15: 0 - 7.5 us (t = TPASETTLE/2)</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMOD</name>
	<description>Time spend for mod tuning
0 - 15: 0 - 15 us (t = TMOD)</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TFINE</name>
	<description>Time spend for fine tuning
0 - 15: 0 - 15 us (t = TFINE)</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMEDIUM</name>
	<description>Time spend for medium tuning
0 - 15: 0 - 7.5 us (t = TMEDIUM/2)
If &lt; 1 us and amplitude calibration is enabled TMEDIUM = 1 us.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TCOARSE</name>
	<description>Time spend for coarse tuning
0 - 15: 0 - 7.5 us (t = TCOARSE/2)</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_INIT_CTRL_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000005</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCOMODIC</name>
	<description>Initial condition for mod cap bank.
(signed)</description>
	<bitRange>[28:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOFINEIC</name>
	<description>Initial condition for fine cap bank.
(signed)</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOMEDIUMIC</name>
	<description>Initial condition for medium cap bank.
(signed)</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOCOARSEIC</name>
	<description>Initial condition for coarse cap bank.
(signed)</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDCO_CAL_CTRL1_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00009b9b</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>KDCOLF_IN_1M</name>
	<description>Gain setting for the low frequency path in case of not using the calibrated KDCOHF for 1M mode (uint8).</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOHFIC_1M</name>
	<description>Initial gain setting for the high frequency path for 1M mode (uint8).</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDCO_CAL_CTRL2_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x4c14000a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>KDCOESTDEV</name>
	<description>Frequency deviation used for KDCO estimation:
0: 500 kHz
1: 250 kHz (default)
2: 125 kHz
3: 62.5 kHz</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOCALTX</name>
	<description>Enable for KDCO calibration in transmit mode.</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOCALRX</name>
	<description>Enable for KDCO calibration in receive mode.</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOLFCALEN</name>
	<description>Enable the use of the (calibrated) value for KDCOHF for the low frequency path.</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TKDCOCAL</name>
	<description>Time spend for KDCO calibration settling:
0: 0.5 us 16
1: 1 us 32
2: 2 us 64
3: 4 us 128
4: 8 us</description>
	<bitRange>[26:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOCN_IC</name>
	<description>Initial condition for channel number related to calibration result.</description>
	<bitRange>[22:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KMOD_ALPHA_1M</name>
	<description>KDCOHF channel dependent trimming constant for 1M mode.
0: No trimming.
&gt;0: KDCOHF is modified with a factor: 1-SGNx(KMOD_ALPHA_1M)x(CN-CN_CAL_RD)/4096</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDCO_RD_REG</name>
	
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>CAL_KDCOCAL</name>
	<description>Calibration state of the KDCO calibration.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDCOCN</name>
	<description>Channel number related to calibration result.</description>
	<bitRange>[22:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDCO_HF_OUT</name>
	<description>kmod_alpha compensated KDCO gain.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDCO_HF_INT</name>
	<description>KDCO gain.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDTCTDC_CAL_CTRL1_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>KDTCIC</name>
	<description>Initial condition for the DTC gain correction.
Calculated according to the following formula:
(DTCres x flo/2)-1 = (kdtcic[6:0]+128)x2kdtcic[8:7]-4
Where DTCres = 24ps for BARIUM</description>
	<bitRange>[31:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCN_IC</name>
	<description>Initial condition for channel number related to calibration result.</description>
	<bitRange>[22:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTC_PIPELINE_BYPASS</name>
	<description>Bypass the extra register on prv_phr.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KTDC_IN</name>
	<description>TDC gain setting in case of not using the calibrated gain setting.</description>
	<bitRange>[14:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTC_ALPHA</name>
	<description>KDTC channel dependent trimming constant.
0: No trimming.
&gt;0: KDTC is modified with a factor: 1-SGNx(KDTC_ALPHA)x(CN-CN_CAL_RD)/32768</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDTCTDC_CAL_CTRL2_REG</name>
	
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00007f50</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PHRDLY_EXTRA</name>
	<description>Extra one delay to be added to PHRDLY path.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TKDTCCAL</name>
	<description>Time spend waiting for DTC calibration (0-15) 0 - 15 us t = tkdtccal/2.</description>
	<bitRange>[14:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PHRDLY</name>
	<description>Delay phr used for kdtc calibration by 1-4 samples, default: 4 samples (3).</description>
	<bitRange>[10:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KTDCCALEN</name>
	<description>Enable calibration of TDC via DTC calibration.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCALLG</name>
	<description>Loopgain setting used for DTC calibration.</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCAL_INV</name>
	<description>Invert sign of kdtc calibration loop (default: 0).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCALMOD1P</name>
	<description>Chicken bit to change phase of KDTC cal mode 1 phase.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCALMOD</name>
	<description>Mode select for KDTC alogrithm:
0: Just-in-time algorithm (least intrusive)
1: Interger lock to Fref/2 and use second clock phase for calibration (no issue with local optimum)</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCALEN</name>
	<description>Enable DTC calibration.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDTC_RD_REG</name>
	
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>CAL_KDTCCAL</name>
	<description>Calibration state of the KDTC calibration.</description>
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDTC_ALPHA_COMP</name>
	<description>KDTC_ALPHA compensated DTC gain setting. Used as TDC gain setting used to correct loopgain.</description>
	<bitRange>[24:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDTCCN</name>
	<description>Channel number related to calibration result.</description>
	<bitRange>[15:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDTC_OUT</name>
	<description>DTC gain setting updated in tuning state 13. Used for register readback.</description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_LF_CTRL1_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000818c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FINEKZ</name>
	<description>Corner frequency setting of the first order low-pass filter that is used for tuning the fine bank.</description>
	<bitRange>[15:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FINEK</name>
	<description>Loopfilter loopgain frequency during fine tuning.</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FINETAU</name>
	<description>First order low-pass filter c.rst_ner frequency during fine tuning.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_LF_CTRL2_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x1ca2879e</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RST_TAU_EN</name>
	<description>Enable state machine to control reset of tau filter.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODKZ</name>
	<description>Loopgain setting of the loop-filter that is used for tuning the MOD bank.</description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODK</name>
	<description>Corner frequency setting of the zero filter that is used for tuning the MOD bank.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODTAU</name>
	<description>Corner frequency setting of the first order low-pass filter that is used for tuning the MOD bank.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODK_TUNE</name>
	<description>Loopfilter loopgain frequency during mod tuning.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODTAU_TUNE</name>
	<description>First order low-pass filter c.rst_ner frequency during mod tuning.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_MISC_CTRL_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000da</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>PHR_FRAC_PRESET_VAL</name>
	<description>Preset value for the fractional counter to be set with the first clk_ckr available after the core reset. The counter will start accumulating on this preset value after the active. The preset value is to be used for ToF application.</description>
	<bitRange>[23:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENFCWMOD</name>
	<description>Enable two point modulation.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENRESIDUE</name>
	<description>Enable residue correction .</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODDLY</name>
	<description>Delay modulation (injected at the capcitor bank) by 0-3 samples.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESDLY</name>
	<description>Delay residue by 0-3 samples.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DLYFCWDT</name>
	<description>Delay reference path of the two point modulation.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_MON_CTRL_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00fc0f83</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QUALMONFRCEN</name>
	<description>Force enable of the clock quality monitor.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QUALMONTRHLD</name>
	<description>Clock quality monitoring threshold.</description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QUALMONWND</name>
	<description>Clock quality monitoring window length.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QUALMONMOD</name>
	<description>Clock quality monitoring mode:
0: Highpass output
1: TDC
2: Lowpass output
3: Loop filter output</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HOLD_STATE</name>
	<description>Set a break point at which the tuning state machine will hold it's state.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFMEAS_MODE</name>
	<description>RF measurement mode for the Divider calibrations.
0 : Jerzy RF measurement.
1 (default): RF measurement for divider calibration.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENRFMEAS</name>
	<description>Enable open loop frequency measurement.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMREN</name>
	<description>Enable timer for measuring PLL settling time.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TFREQMEAS</name>
	<description>Frequency measurement time
Two lsb's form the linear part, the three MSB's are the exponent
Time [us] = 0.5+((4+lin)*(2^(exp-1)))
tfreqmeas Time [us]
0: 2.5
1: 3
2: 3.5
3: 4
4: 4.5
5: 5.5
6: 6.5
7: 7.5
8: 8.5
9: 10.5
10: 12.5
11: 14.5
12: 16.5
13: 20.5
14: 24.5
15: 28.5
16: 32.5
17: 40.5
18: 48.5
19: 56.5
20: 64.5
21: 80.5
22: 96.5
23: 112.5
24: 128.5
25: 160.5
26: 192.5
27: 224.5
28: 256.5
29: 320.5
30: 384.5
31: 448.5</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_OVERRULE_CTRL1_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OVR_DTC_OH_WR</name>
	<description>Overrule value (decimal) for the dtc_oh.</description>
	<bitRange>[31:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DTC_OH_SEL</name>
	<description>Overrule dtc_oh output.
0: Normal function (default)
1: Overrule dtc_oh output by OVR_DTC_OH_WR</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOAMP_WR</name>
	<description>Overrule value for the dcoamp.</description>
	<bitRange>[20:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOAMP_SEL</name>
	<description>Overrule dcoamp output.
0: Normal function (default)
1: Overrule dcoamp output by OVR_DCOAMP_WR</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOAMPHOLD_WR</name>
	<description>Overrule value for the dcoamp_hold..</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOAMPHOLD_SEL</name>
	<description>Overrule dcoamphold output.
0: Normal function (default)
1: Overrule dcoamphold output by OVR_DCOAMPHOLD_WR</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RDYFORDIV_WR</name>
	<description>Overrule value for the rdy_for_div input.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RDYFORDIV_SEL</name>
	<description>Overrule rdy_for_div input.
0: Normal function (default)
1: Overrule rdy_for_div input by OVR_RDYFORDIV_WR</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_VPAEN_WR</name>
	<description>Overrule value for the vpa_en.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_VPAEN_SEL</name>
	<description>Overrule vpaen.
0: Normal function (default)
1: Overrule vpaen by OVR_VPAEN_WR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_SRESETN_WR</name>
	<description>Overrule value for the sreset_n.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_SRESETN_SEL</name>
	<description>Overrule sreset_n of the modulator.
0: Normal function (default)
1: Overrule sreset_n by OVR_SRESETN_WR</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_ENPAIN_WR</name>
	<description>Overrule value for the enpain.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_ENPAIN_SEL</name>
	<description>Overrule enpain input.
0: Normal function (default)
1: Overrule enpain input by OVR_ENPAIN_WR</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXBIT_WR</name>
	<description>Overrule value for the rxbit.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXBIT_SEL</name>
	<description>Overrule rxbit input.
0: Normal function (default)
1: Overrule rxbit input by OVR_RXBIT_WR</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_ACTIVE_WR</name>
	<description>Overrule value for the active.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_ACTIVE_SEL</name>
	<description>Overrule active input.
0: Normal function (default)
1: Overrule active input by OVR_ACTIVE_WR</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_OVERRULE_CTRL2_REG</name>
	
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OVR_DCOMOD_WR</name>
	<description>Overrule value (decimal) for the internal dcomod.The overrule value is in the same format as the SDM output.</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOMOD_SEL</name>
	<description>Overrule dcomod.
0: Normal function (default)
1: Overrule dcomod by OVR_DCOMOD_WR</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOFINE_WR</name>
	<description>Overrule value (decimal) for the internal dcofine.The overrule value is in the same format as the ACC output.</description>
	<bitRange>[22:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOFINE_SEL</name>
	<description>Overrule dcofine.
0: Normal function (default)
1: Overrule dcofine by OVR_DCOFINE_WR</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOMEDIUM_WR</name>
	<description>Overrule value (decimal) for the internal dcomedium.The overrule value is in the same format as the ACC output.</description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOMEDIUM_SEL</name>
	<description>Overrule dcomedium.
0: Normal function (default)
1: Overrule dcomedium by OVR_DCOMEDIUM_WR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOCOARSE_WR</name>
	<description>Overrule value (decimal) for the internal dcocoarse.The overrule value is in the same format as the ACC output.</description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOCOARSE_SEL</name>
	<description>Overrule dcocoarse.
0: Normal function (default)
1: Overrule dcocoarse by OVR_DCOCOARSE_WR</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_OVERRULE_CTRL3_REG</name>
	
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>OVR_RXDIV_FB_EN_WR</name>
	<description>Overrule value for the rxdiv_fb_en output.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXDIV_FB_EN_SEL</name>
	<description>Overrule rxdiv_fb_en output.
0: Normal function (default)
1: Overrule rxdiv_fb_en output by OVR_RXDIV_FB_EN_WR</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_FBDIV_EN_WR</name>
	<description>Overrule value for the fbdiv_en output.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_FBDIV_EN_SEL</name>
	<description>Overrule fbdiv_en output.
0: Normal function (default)
1: Overrule fbdiv_en output by OVR_FBDIV_EN_WR</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_TXDIV_EN_WR</name>
	<description>Overrule value for the txdiv_en output.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_TXDIV_EN_SEL</name>
	<description>Overrule txdiv_en output.
0: Normal function (default)
1: Overrule txdiv_en output by OVR_TXDIV_EN_WR</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXDIV_EN_WR</name>
	<description>Overrule value for the rxdiv_en output.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXDIV_EN_SEL</name>
	<description>Overrule rxdiv_en.
0: Normal function (default)
1: Overrule rxdiv_en output by OVR_RXDIV_EN_WR</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_PLLFCWDT_RD_REG</name>
	
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00258800</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>PLLFCWDT</name>
	<description>PLLFCWDT.</description>
	<bitRange>[22:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_RFPT_CTRL_REG</name>
	
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>RFPT_RATE</name>
	<description>RFPT rate setting
0: 16MSPS
1: 8 MSPS</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INV_CKRFPT</name>
	<description>Invert clock registering output of the RFPT interface.

Note:
Please check bug2522A_018 (DEM 16Msps data need 16MHz RFCU clock).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFPT_MUX</name>
	<description>Multiplexer setting for RFPT interface output.
The following data will be provided to the rfpt interface:
0: Disabled
1: {5'd0, tdc_invert, tdc_b}
2: {tdc_t_reg[20:5]}
3: {dcocoarse, 1'd0,dcomedium, 2'd0,dcofine}
4: {8'd0, dcomod_sdm}
5: {1'd0, phr_int0, phe_int_int}
6: {2'd0, phe_int, 1'd0,phv_int}
7: {7'd0, kdtc_int}
8: {2'd0, int_state,lpout}
9: {7'd0, lfout_int,lfout_frac}
10: {4'd0, txfcwdt}
11: {1'd0, dcocoarse_t}
12: {2'd0, dcofine_t, dcomedium_t}
13: {dcomod_t[15:0]}
14: {rdata_in}
15: {5'd0, dcoamphold_in, rxdiven_in, txdiven_in, fbdiven_in, rxdivfben_in, dcomod_b, dcofine_b}

Note:
- Please check bug2522A_018 (DEM 16Msps data need 16MHz RFCU clock).
- Before enabling the RFPT output by setting RFPT_MUX to a non-zero value, RF_ADPLLDIG_RFMON_CTRL_REG[ADPLLDIG_RFMON_MUX_SEL] should be set to the value (a value other than 'b000 and 'b001) which enables adplldig_rfmon data capturing.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_SDMOD_CTRL_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000039</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SDMMODETX</name>
	<description>Sigma delta modulator mode for TX:
0: Disabled
1: MASH I
3: MASH II
5: MASH I + with dithering
7: MASH II + with dithering</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDMMODERX</name>
	<description>Sigma delta modulator mode for RX:
0: Disabled
1: MASH I
3: MASH II
5: MASH I + with dithering
7: MASH II + with dithering</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_TUNESTATE_RD_REG</name>
	
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>TMRVAL</name>
	<description>Current timer value. Timer can be used to determine PLL settling time and is used for frequency measurement.</description>
	<bitRange>[13:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TUNE_STATE</name>
	<description>Binary coded state of the tuning state machine.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_TXMOD_CTRL_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>INV_CKMODEXT</name>
	<description>Invert the clock, which captures the external modulated data or tx_data_en.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_MODE</name>
	<description>Two-point modulation MUX:
0,3: mod_hf = mod_in
mod_lf = mod_in
1: mod_hf = 0
mod_lf = mod_in
2: mod_hf = mod_in
mod_lf = 0</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EO_PACKET_DIS</name>
	<description>The block will normally detect the end of a data packet by the missing tx_data_en pulses.
The outputs will be smoothly return to zero when an end of a data packet has been deteted.
The end of a data packet detected can be disabled by setting eo_packet_dis = 1. This is
normally/never used and eo_packet_dis should always be set to zero.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MOD_INDEX</name>
	<description>Modulation index selection:
0: h = 1/2 (dF = 250 kHz)
1: h = 11/32 (dF = 172 kHz):
2: h = 17/32 (dF = 266 kHz)
3: h = 69/128 (dF = 270 kHz)</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_DATA_INV</name>
	<description>Select polarity of the modulation prior to pulse shaping
0: Normal operation
1: Invert modulation signal</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BT_SEL</name>
	<description>The BT product for the Gaussian pulse can take the values 0.5 or 0.6.
0: BT = 0.5
1: BT = 0.6</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>ANAMISC</name>
	<version>1.0</version>
	<description>ANAMISC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_REF_CNT_REG</name>
	<description>Count value for oscillator calibration</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REF_CNT_VAL</name>
	<description>Indicates the calibration time, with a decrement counter to 1. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_SEL_REG</name>
	<description>Select clock for oscillator calibration</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>EXT_CNT_EN_SEL</name>
	<description>0 : Enable XTAL_CNT counter by the REF_CLK selected by REF_CLK_SEL.
1 : Enable XTAL_CNT counter from an external input.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CAL_START</name>
	<description>Writing a '1' starts a calibration of the clock selected by CLK_REF_SEL_REG[REF_CLK_SEL]. This bit is cleared when calibration is finished, and CLK_REF_VAL is ready. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CLK_SEL</name>
	<description>Select clock input for calibration:
0x0 : RC32K
0x1 : RC32M
0x2 : XTAL32K
0x3 : RCX</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_VAL_H_REG</name>
	<description>XTAL32M reference cycles, higher 16 bits</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the number of DIVN clock cycles counted during the calibration time, defined with REF_CNT_VAL </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CLK_REF_VAL_L_REG</name>
	<description>XTAL32M reference cycles, lower 16 bits</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the number of DIVN clock cycles counted during the calibration time, defined with REF_CNT_VAL </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>BLE</name>
	<version>1.0</version>
	<description>BLE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>532</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BLE_ACTSCANSTAT_REG</name>
	<description>Active scan register</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00010001</resetValue>
	<resetMask>0x01ff01ff</resetMask>
	<fields><field>
	<name>BACKOFF</name>
	<description>Active scan mode back-off counter initialization value. </description>
	<bitRange>[24:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UPPERLIMIT</name>
	<description>Active scan mode upper limit counter value. </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_ADVCHMAP_REG</name>
	<description>Advertising Channel Map</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>ADVCHMAP</name>
	<description>Advertising Channel Map, defined as per the advertising connection settings. Contains advertising channels index 37 to 39. If ADVCHMAP[i] equals:
0: Do not use data channel i+37.
1: Use data channel i+37. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_ADVTIM_REG</name>
	<description>Advertising Packet Interval</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>ADVINT</name>
	<description>Advertising Packet Interval defines the time interval in between two ADV_xxx packet sent. Value is in us.
Value to program depends on the used Advertising Packet type and the device filtering policy. </description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESCNTL_REG</name>
	<description>Start AES register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>AES_MODE</name>
	<description>0: Cipher mode
1: Decipher mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AES_START</name>
	<description>Writing a 1 starts AES-128 ciphering/deciphering process.
This bit is reset once the process is finished (i.e. ble_crypt_irq interrupt occurs, even masked) </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY127_96_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY127_96</name>
	<description>AES encryption 128-bit key. Bit 127 down to 96 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY31_0_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY31_0</name>
	<description>AES encryption 128-bit key. Bit 31 down to 0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY63_32_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY63_32</name>
	<description>AES encryption 128-bit key. Bit 63 down to 32 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY95_64_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY95_64</name>
	<description>AES encryption 128-bit key. Bit 95 down to 64 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESPTR_REG</name>
	<description>Pointer to the block to encrypt/decrypt</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>AESPTR</name>
	<description>Pointer to the memory zone where the block to cipher/decipher using AES-128 is stored. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BASETIMECNTCORR_REG</name>
	<description>Base Time Counter</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>BASETIMECNTCORR</name>
	<description>Base Time Counter correction value. </description>
	<bitRange>[26:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BASETIMECNT_REG</name>
	<description>Base time reference counter</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>BASETIMECNT</name>
	<description>Value of the 625us base time reference counter. Updated each time SAMPCLK is written. Used by the SW in order to synchronize with the HW </description>
	<bitRange>[26:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_BDADDRL_REG</name>
	<description>BLE device address LSB register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BDADDRL</name>
	<description>Bluetooth Low Energy Device Address. LSB part.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BDADDRU_REG</name>
	<description>BLE device address MSB register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>PRIV_NPUB</name>
	<description>Bluetooth Low Energy Device Address privacy indicator
0: Public Bluetooth Device Address
1: Private Bluetooth Device Address </description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BDADDRU</name>
	<description>Bluetooth Low Energy Device Address. MSB part. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BLEMPRIO0_REG</name>
	<description>Coexistence interface Priority 0 Register</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3489adef</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLEM7</name>
	<description>Set Priority value for Passive Scanning </description>
	<bitRange>[31:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM6</name>
	<description>Set Priority value for Non-Connectable Advertising </description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM5</name>
	<description>Set Priority value for Connectable Advertising BLE message </description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM4</name>
	<description>Set Priority value for Active Scanning BLE message </description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM3</name>
	<description>Set Priority value for Initiating (Scanning) BLE message </description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM2</name>
	<description>Set Priority value for Data Channel transmission BLE message </description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM1</name>
	<description>Set Priority value for LLCP BLE message </description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM0</name>
	<description>Set Priority value for Initiating (Connection Request Response) BLE message </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BLEMPRIO1_REG</name>
	<description>Coexistence interface Priority 1 Register</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x30000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLEMDEFAULT</name>
	<description>Set default priority value for other BLE message than those defined above </description>
	<bitRange>[31:28]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_CNTL2_REG</name>
	<description>BLE Control Register 2</description>
	<addressOffset>0x00000200</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLE_PHY_ERR_MSK_N</name>
	
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_ARP_ERR_MSK_N</name>
	<description>When cleared to &quot;0&quot; then it masks the BLE_ARP_ERR_STAT in order to not trigger a BLE_ERROR_IRQ.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_ARP_PHY_ERR_STAT</name>
	<description>When set to &quot;1&quot; then an error occured in BLE ARP sub-block and the BLE_GEN_IRQ will be aserted.
It will be set if the ARP_ERROR or PHY_ERROR will be asserted and if the BLE_ARP_ERR_MSK is set to &quot;1&quot;.
Writing the value &quot;1&quot; will acknowledge and clear this field.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_RSSI_SEL</name>
	<description>0: (default) Select Peak-hold RSSI value during the SYNC_FOUND event:
CS-&gt;RXRSSI[7:0] = RF_RSSI_RESULT_REG-&gt;RSSI_LATCHED_RD[9:2].
1: Select the Average RSSI value during the SYNC_FOUND event:
CS-&gt;RXRSSI[7:0] = RF_RSSI_RESULT_REG-&gt;RSSI_AVG_RD[9:2].</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUPLPSTAT</name>
	<description>The status of the BLE_WAKEUP_LP_IRQ. The Interrupt Service Routine of BLE_WAKEUP_LP_IRQ should return only when the WAKEUPLPSTAT is cleared.
Note that BLE_WAKEUP_LP_IRQ is automatically acknowledged after the power up of the Radio Subsystem, plus one Low Power Clock period. </description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SW_RPL_SPI</name>
	<description>Keep to 0. </description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BB_ONLY</name>
	<description>Keep to 0.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_PTI_SOURCE_SEL</name>
	<description>0: Provide to COEX block the PTI value indicated by the Control Structure. Recommended value is &quot;0&quot;.
1: Provide to COEX block the PTI value generated dynamically by the BLE core, which is based on the PTI of the Control Structure.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_CLK_SEL</name>
	<description>BLE Clock Select.
Specifies the BLE master clock absolute frequency in MHz.
Typical values are 16 and 8.
Value depends on the selected XTAL frequency and the value of CLK_RADIO_REG[BLE_DIV] bitfield. For example, if XTAL oscillates at 16MHz and CLK_RADIO_REG[BLE_DIV] = 1 (divide by 2), then BLE master clock frequency is 8MHz and BLE_CLK_SEL should be set to value 8.
The selected BLE master clock frequency (affected by BLE_DIV and BLE_CLK_SEL) must be modified and set only during the initialization time, i.e. before setting BLE_RWBLECNTL_REG[RWBLE_EN] to 1.
Refer also to BLE_RWBLECONF_REG[CLK_SEL].</description>
	<bitRange>[14:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_PWRDN_ALLOW</name>
	<description>This active high signal indicates when it is allowed for the BLE core (embedded in the Radio sub-System power domain) to be powered down.
After the assertion of the BLE_DEEPSLCNTL_REG[DEEP_SLEEP_ON] a hardware sequence based on the Low Power clock will cause the assertion of RADIO_PWRDN_ALLOW. The RADIO_PWRDN_ALLOW will be cleared to &quot;0&quot; when the BLE core exits from the sleep state, i.e. when the BLE_SLP_IRQ will be asserted.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MON_LP_CLK</name>
	<description>The SW can only write a &quot;0&quot; to this bit.
Whenever a positive edge of the low power clock used by the BLE Timers is detected, then the HW will automatically set this bit to &quot;1&quot;. This functionality will not work if BLE Timer is in reset state (refer to CLK_RADIO_REG[BLE_LP_RESET]).
This bit can be used for SW synchronization, to debug the low power clock, etc.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BLE_CLK_STAT</name>
	<description>0: BLE uses low power clock
1: BLE uses master clock </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BLE_DIAG_OVR</name>
	<description>1: Overrule BLE_DIAG.
0: BLE_DIAG is not overruled.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMACCERRMSK</name>
	<description>Exchange Memory Access Error Mask:
When cleared to &quot;0&quot; the EM_ACC_ERR will not cause an BLE_ERROR_IRQ interrupt.
When set to &quot;1&quot; an BLE_ERROR_IRQ will be generated as long as EM_ACC_ERR is &quot;1&quot;. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMACCERRACK</name>
	<description>Exchange Memory Access Error Acknowledge.
When the SW writes a &quot;1&quot; to this bit then the EMACCERRSTAT bit will be cleared.
When the SW writes &quot;0&quot; it will have no affect.
The read value is always &quot;0&quot;. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EMACCERRSTAT</name>
	<description>Exchange Memory Access Error Status:
The bit is read-only and can be cleared only by writing a &quot;1&quot; at EMACCERRACK bitfield.
This bit will be set to &quot;1&quot; by the hardware when the controller will access an EM page that is not mapped according to the EM_MAPPING value.
When this bit is &quot;1&quot; then the BLE_ERROR_IRQ will be asserted as long as EMACCERRMSK is &quot;1&quot;. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_COEXIFCNTL0_REG</name>
	<description>Coexistence interface Control 0 Register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x003300f3</resetMask>
	<fields><field>
	<name>WLCRXPRIOMODE</name>
	<description>Defines Bluetooth Low Energy packet ble_rx mode behavior.
00: Rx indication excluding Rx Power up delay (starts when correlator is enabled)
01: Rx indication including Rx Power up delay
10: Rx High priority indicator
11: n/a</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLCTXPRIOMODE</name>
	<description>Defines Bluetooth Low Energy packet ble_tx mode behavior
00: Tx indication excluding Tx Power up delay
01: Tx indication including Tx Power up delay
10: Tx High priority indicator
11: n/a</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLANTXMSK</name>
	<description>Determines how wlan_tx impact BLE Tx and Rx
00: wlan_tx has no impact (default mode)
01: wlan_tx can stop BLE Tx, no impact on BLE Rx
10: wlan_tx can stop BLE Rx, no impact on BLE Tx
11: wlan_tx can stop both BLE Tx and BLE Rx</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLANRXMSK</name>
	<description>Determines how wlan_rx impact BLE Tx and Rx
00: wlan_rx has no impact
01: wlan_rx can stop BLE Tx, no impact on BLE Rx (default mode)
10: wlan_rx can stop BLE Rx, no impact on BLE Tx
11: wlan_rx can stop both BLE Tx and BLE Rx</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYNCGEN_EN</name>
	<description>Determines whether ble_sync is generated or not.
0: ble_sync pulse not generated
1: ble_sync pulse generated</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>COEX_EN</name>
	<description>Enable / Disable control of the MWS/WLAN Coexistence control
0: Coexistence interface disabled
1: Coexistence interface enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_COEXIFCNTL1_REG</name>
	<description>Coexistence interface Control 1 Register</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x1f1f7f7f</resetMask>
	<fields><field>
	<name>WLCPRXTHR</name>
	<description>Applies on ble_rx if WLCRXPRIOMODE equals 10
Determines the threshold for Rx priority setting.
If ble_pti[3:0] output value is greater than WLCPRXTHR, then Rx Bluetooth Low Energy priority is considered as high, and must be provided to the WLAN coexistence interface </description>
	<bitRange>[28:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLCPTXTHR</name>
	<description>Applies on ble_tx if WLCTXPRIOMODE equals 10
Determines the threshold for priority setting.
If ble_pti[3:0] output value is greater than WLCPTXTHR, then Tx Bluetooth Low Energy priority is considered as high, and must be provided to the WLAN coexistence interface </description>
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLCPDURATION</name>
	<description>Applies on ble_tx if WLCTXPRIOMODE equals 10
Applies on ble_rx if WLCRXPRIOMODE equals 10
Determines how many s the priority information must be maintained
Note that if WLCPDURATION = 0x00, then Tx/Rx priority levels are maintained till Tx/Rx EN are de-asserted. </description>
	<bitRange>[14:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLCPDELAY</name>
	<description>Applies on ble_tx if WLCTXPRIOMODE equals 10.
Applies on ble_rx if WLCRXPRIOMODE equals 10.
Determines the delay (in us) in Tx/Rx enables rises the time Bluetooth Low energy Tx/Rx priority has to be provided . </description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_CURRENTRXDESCPTR_REG</name>
	<description>Rx Descriptor Pointer for the Receive Buffer Chained List</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ETPTR</name>
	<description>Exchange Table Pointer that determines the starting point of the Exchange Table</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CURRENTRXDESCPTR</name>
	<description>Rx Descriptor Pointer that determines the starting point of the Receive Buffer Chained List </description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEBUGADDMAX_REG</name>
	<description>Upper limit for the memory zone</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>REG_ADDMAX</name>
	<description>Upper limit for the Register zone indicated by the reg_inzone flag </description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EM_ADDMAX</name>
	<description>Upper limit for the Exchange Memory zone indicated by the em_inzone flag </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEBUGADDMIN_REG</name>
	<description>Lower limit for the memory zone</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>REG_ADDMIN</name>
	<description>Lower limit for the Register zone indicated by the reg_inzone flag </description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EM_ADDMIN</name>
	<description>Lower limit for the Exchange Memory zone indicated by the em_inzone flag </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEEPSLCNTL_REG</name>
	<description>Deep-Sleep control register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>EXTWKUPDSB</name>
	<description>External Wake-Up disable
0: RW-BLE Core can be woken by external wake-up
1: RW-BLE Core cannot be woken up by external wake-up </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEEP_SLEEP_STAT</name>
	<description>Indicator of current Deep Sleep clock mux status:
0: RW-BLE Core is not yet in Deep Sleep Mode
1: RW-BLE Core is in Deep Sleep Mode (only low_power_clk is running) </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SOFT_WAKEUP_REQ</name>
	<description>Wake Up Request from RW-BLE Software. Applies when system is in Deep Sleep Mode. It wakes up the RW-BLE Core when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEEP_SLEEP_CORR_EN</name>
	<description>625us base time reference integer and fractional part correction. Applies when system has been woken-up from Deep Sleep Mode. It enables Fine Counter and Base Time counter when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DEEP_SLEEP_ON</name>
	<description>0: RW-BLE Core in normal active mode
1: Request RW-BLE Core to switch in deep sleep mode.
This bit is reset on DEEP_SLEEP_STAT falling edge. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DEEP_SLEEP_IRQ_EN</name>
	<description>Always set to &quot;3&quot; when DEEP_SLEEP_ON is set to &quot;1&quot;.
It controls the generation of BLE_WAKEUP_LP_IRQ. </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEEPSLSTAT_REG</name>
	<description>Duration of the last deep sleep phase register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEEPSLDUR</name>
	<description>Actual duration of the last deep sleep phase measured in low_power_clk clock cycle. DEEPSLDUR is set to zero at the beginning of the deep sleep phase, and is incremented at each low_power_clk clock cycle until the end of the deep sleep phase. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_DEEPSLWKUP_REG</name>
	<description>Time (measured in Low Power clock cycles) in Deep Sleep Mode before waking-up the device</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEEPSLTIME</name>
	<description>Determines the time in low_power_clk clock cycles to spend in Deep Sleep Mode before waking-up the device. This ensures a maximum of 37 hours and 16mn sleep mode capabilities at 32kHz. This ensures a maximum of 36 hours and 16mn sleep mode capabilities at 32.768kHz </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGCNTL2_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x0000020c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG7_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG7</name>
	<description>Only relevant when DIAG7_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG7. </description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG6_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG6</name>
	<description>Only relevant when DIAG6_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG6. </description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG5_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG5</name>
	<description>Only relevant when DIAG5_EN= 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG5.</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG4_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG4</name>
	<description>Only relevant when DIAG4_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG4.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGCNTL3_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x00000210</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG7_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG7_BIT</name>
	<description>Selects which bit from the DIAG7 word will be forwarded to bit 7 of the BLE DIagnostic Port.</description>
	<bitRange>[30:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG6_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG6_BIT</name>
	<description>Selects which bit from the DIAG6 word will be forwarded to bit 6 of the BLE DIagnostic Port.</description>
	<bitRange>[26:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG5_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG5_BIT</name>
	<description>Selects which bit from the DIAG5 word will be forwarded to bit 5 of the BLE DIagnostic Port.</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG4_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG4_BIT</name>
	<description>Selects which bit from the DIAG4 word will be forwarded to bit 4 of the BLE DIagnostic Port.</description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG3_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG3_BIT</name>
	<description>Selects which bit from the DIAG3 word will be forwarded to bit 3 of the BLE DIagnostic Port.</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2_BIT</name>
	<description>Selects which bit from the DIAG2 word will be forwarded to bit 2 of the BLE DIagnostic Port.</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1_BIT</name>
	<description>Selects which bit from the DIAG1 word will be forwarded to bit 1 of the BLE DIagnostic Port.</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0_BIT</name>
	<description>Selects which bit from the DIAG0 word will be forwarded to bit 0 of the BLE DIagnostic Port.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGCNTL_REG</name>
	<description>Diagnostics Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG3_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG3</name>
	<description>Only relevant when DIAG3_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG3. </description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2</name>
	<description>Only relevant when DIAG2_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG2. </description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1</name>
	<description>Only relevant when DIAG1_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG1. </description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0</name>
	<description>Only relevant when DIAG0_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG0. </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGSTAT_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG3STAT</name>
	<description>Directly connected to ble_dbg3[7:0] output. Debug use only. </description>
	<bitRange>[31:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAG2STAT</name>
	<description>Directly connected to ble_dbg2[7:0] output. Debug use only. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAG1STAT</name>
	<description>Directly connected to ble_dbg1[7:0] output. Debug use only. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAG0STAT</name>
	<description>Directly connected to ble_dbg0[7:0] output. Debug use only. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_EM_BASE_REG</name>
	<description>Exchange Memory Base Register</description>
	<addressOffset>0x00000208</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLE_EM_BASE_16_10</name>
	<description>The physical address on the system memory map of the base of the Exchange Memory.</description>
	<bitRange>[16:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_ENBPRESET_REG</name>
	<description>Time in low power oscillator cycles register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TWEXT</name>
	<description>Minimum and recommended value is &quot;TWIRQ_RESET + 1&quot;.
In the case of wake-up due to an external wake-up request, TWEXT specifies the time delay in low power oscillator cycles to deassert BLE_WAKEUP_LP_IRQ.
Refer also to GP_CONTROL_REG[BLE_WAKEUP_REQ].
Range is [0...64 ms] for 32kHz; [0...62.5 ms] for 32.768kHz </description>
	<bitRange>[31:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TWIRQ_SET</name>
	<description>Minimum value is &quot;TWIRQ_RESET + 1&quot;.
Time in low power oscillator cycles to set BLE_WAKEUP_LP_IRQ before the BLE sleep timer expiration.
Refer also to BLE_DEEPSLWKUP_REG[DEEPSLTIME].
Range is [0...64 ms] for 32kHz; [0...62.5 ms] for 32.768kHz </description>
	<bitRange>[20:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TWIRQ_RESET</name>
	<description>Recommended value is 1.
Time in low power oscillator cycles to reset BLE_WAKEUP_LP_IRQ before the BLE sleep timer expiration.
Refer also to BLE_DEEPSLWKUP_REG[DEEPSLTIME].
Range is [0...32 ms] for 32kHz; [0...31.25 ms] for 32.768kHz. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_ERRORTYPESTAT_REG</name>
	<description>Error Type Status registers</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>CONCEVTIRQ_ERROR</name>
	<description>Indicates whether two consecutive and concurrent ble_event_irq have been generated, and not acknowledged in time by the RW-BLE Software.
0: No error
1: Error occurred</description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXDATA_PTR_ERROR</name>
	<description>Indicates whether Rx data buffer pointer value programmed is null: this is a major programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TXDATA_PTR_ERROR</name>
	<description>Indicates whether Tx data buffer pointer value programmed is null during Advertising / Scanning / Initiating events, or during Master / Slave connections with non-null packet length: this is a major programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXDESC_EMPTY_ERROR</name>
	<description>Indicates whether Rx Descriptor pointer value programmed in register is null: this is a major programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TXDESC_EMPTY_ERROR</name>
	<description>Indicates whether Tx Descriptor pointer value programmed in Control Structure is null during Advertising / Scanning / Initiating events: this is a major programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CSFORMAT_ERROR</name>
	<description>Indicates whether CS-FORMAT has been programmed with an invalid value: this is a major software programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LLCHMAP_ERROR</name>
	<description>Indicates Link Layer Channel Map error, happens when actual number of CS-LLCHMAP bit set to one is different from CS-NBCHGOOD at the beginning of Frequency Hopping process
0: No error
1: Error occurred </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADV_UNDERRUN</name>
	<description>Indicates Advertising Interval Under run, occurs if time between two consecutive Advertising packet (in Advertising mode) is lower than the expected value.
0: No error
1: Error occurred </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IFS_UNDERRUN</name>
	<description>Indicates Inter Frame Space Under run, occurs if IFS time is not enough to update and read Control Structure/Descriptors, and/or White List parsing is not finished and/or Decryption time is too long to be finished on time
0: No error
1: Error occurred </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>WHITELIST_ERROR</name>
	<description>Indicates White List Timeout error, occurs if White List parsing is not finished on time
0: No error
1: Error occurred</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVT_CNTL_APFM_ERROR</name>
	<description>Indicates Anticipated Pre-Fetch Mechanism error: happens when 2 consecutive events are programmed, and when the first event is not completely finished while second pre-fetch instant is reached.
0: No error
1: Error occured </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVT_SCHDL_APFM_ERROR</name>
	<description>Indicates Anticipated Pre-Fetch Mechanism error: happens when 2 consecutive events are programmed, and when the first event is not completely finished while second pre-fetch instant is reached.
0: No error
1: Error occured </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVT_SCHDL_ENTRY_ERROR</name>
	<description>Indicates Event Scheduler faced Invalid timing programing on two consecutive ET entries (e.g first one with 624s offset and second one with no offset)
0: No error
1: Error occurred </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVT_SCHDL_EMACC_ERROR</name>
	<description>Indicates Event Scheduler Exchange Memory access error, happens when Exchange Memory accesses are not served in time, and blocks the Exchange Table entry read
0: No error
1: Error occurred</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RADIO_EMACC_ERROR</name>
	<description>Indicates Radio Controller Exchange Memory access error, happens when Exchange Memory accesses are not served in time and data are corrupted.
0: No error
1: Error occurred </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKTCNTL_EMACC_ERROR</name>
	<description>Indicates Packet Controller Exchange Memory access error, happens when Exchange Memory accesses are not served in time and Tx/Rx data are corrupted
0: No error
1: Error occurred </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXCRYPT_ERROR</name>
	<description>Indicates real time decryption error, happens when AES-CCM decryption is too slow compared to Packet Controller requests. A 16-bytes block has to be decrypted prior the next block is received by the Packet Controller
0: No error
1: Error occurred </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TXCRYPT_ERROR</name>
	<description>Indicates Real Time encryption error, happens when AES-CCM encryption is too slow compared to Packet Controller requests. A 16-bytes block has to be encrypted and prepared on Packet Controller request, and needs to be ready before the Packet Controller has to send ti
0: No error
1: Error occurred </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_FINECNTCORR_REG</name>
	<description>Phase correction value register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>FINECNTCORR</name>
	<description>Phase correction value for the 625us reference counter (i.e. Fine Counter) in us. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_FINETIMECNT_REG</name>
	<description>Fine time reference counter</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>FINECNT</name>
	<description>Value of the current s fine time reference counter. Updated each time SAMPCLK is written. Used by the SW in order to synchronize with the HW, and obtain a more precise sleep duration </description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_FINETIMTGT_REG</name>
	<description>Fine Timer Target value</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>FINETARGET</name>
	<description>Fine Timer Target value on which a ble_finetgtim_irq must be generated. This timer has a precision of 625 usec: interrupt is generated only when FINETARGET = BASETIMECNT </description>
	<bitRange>[26:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_GROSSTIMTGT_REG</name>
	<description>Gross Timer Target value</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>GROSSTARGET</name>
	<description>Gross Timer Target value on which a ble_grosstgtim_irq must be generated. This timer has a precision of 10ms: interrupt is generated only when GROSSTARGET[22:0] = BASETIMECNT[26:4] and BASETIMECNT[3:0] = 0. </description>
	<bitRange>[22:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_INTACK_REG</name>
	<description>Interrupt acknowledge register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SWINTACK</name>
	<description>SW triggered interrupt acknowledgement bit
Software writing 1 acknowledges the SW triggered interrupt. This bit resets SWINTSTAT and SWINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EVENTAPFAINTACK</name>
	<description>End of event / Anticipated Pre-Fetch Abort interrupt acknowledgement bit
Software writing 1 acknowledges the End of event / Anticipated Pre-Fetch Abort interrupt. This bit resets EVENTAPFAINTSTAT and EVENTAPFAINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FINETGTIMINTACK</name>
	<description>Fine Target Timer interrupt acknowledgement bit
Software writing 1 acknowledges the Fine Timer interrupt. This bit resets FINETGTIMINTSTAT and FINETGTIMINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>GROSSTGTIMINTACK</name>
	<description>Gross Target Timer interrupt acknowledgement bit
Software writing 1 acknowledges the Gross Timer interrupt. This bit resets GROSSTGTIMINTSTAT and GROSSTGTIMINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>ERRORINTACK</name>
	<description>Error interrupt acknowledgement bit
Software writing 1 acknowledges the Error interrupt. This bit resets ERRORINTSTAT and ERRORINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CRYPTINTACK</name>
	<description>Encryption engine interrupt acknowledgement bit Software writing 1 acknowledges the Encryption engine interrupt. This bit resets CRYPTINTSTAT and CRYPTINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EVENTINTACK</name>
	<description>End of Event interrupt acknowledgment bit
Software writing 1 acknowledges the End of Advertising / Scanning / Connection interrupt. This bit resets SLPINTSTAT and SLPINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SLPINTACK</name>
	<description>End of Deep Sleep interrupt acknowledgment bit
Software writing 1 acknowledges the End of Sleep Mode interrupt. This bit resets SLPINTSTAT and SLPINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RXINTACK</name>
	<description>Packet Reception interrupt acknowledgment bit
Software writing 1 acknowledges the Rx interrupt. This bit resets RXINTSTAT and RXINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CSCNTINTACK</name>
	<description>625us base time reference interrupt acknowledgment bit
Software writing 1 acknowledges the CLKN interrupt. This bit resets CLKINTSTAT and CLKINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>BLE_INTCNTL_REG</name>
	<description>Interrupt controller register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000811f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CSCNTDEVMSK</name>
	<description>CSCNT interrupt mask during event. This bit allows to enable CSCNT interrupt generation during events (i.e. advertising, scanning, initiating, and connection)
0: CSCNT Interrupt not generated during events.
1: CSCNT Interrupt generated during events. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWINTMSK</name>
	<description>SW triggered interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EVENTAPFAINTMSK</name>
	<description>End of event / anticipated pre-fetch abort interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FINETGTIMINTMSK</name>
	<description>Fine Target Timer Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GROSSTGTIMINTMSK</name>
	<description>Gross Target Timer Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERRORINTMSK</name>
	<description>Error Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTINTMSK</name>
	<description>Encryption engine Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EVENTINTMSK</name>
	<description>End of event Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SLPINTMSK</name>
	<description>Sleep Mode Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXINTMSK</name>
	<description>Rx Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CSCNTINTMSK</name>
	<description>625us Base Time Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_INTRAWSTAT_REG</name>
	<description>Interrupt raw status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SWINTRAWSTAT</name>
	<description>SW triggered interrupt raw status
0: No SW triggered interrupt.
1: A SW triggered interrupt is pending. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTAPFAINTRAWSTAT</name>
	<description>End of event / Anticipated Pre-Fetch Abort interrupt raw status
0: No End of Event interrupt.
1: An End of Event interrupt is pending. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FINETGTIMINTRAWSTAT</name>
	<description>Fine Target Timer Error interrupt raw status
0: No Fine Target Timer interrupt.
1: A Fine Target Timer interrupt is pending. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GROSSTGTIMINTRAWSTAT</name>
	<description>Gross Target Timer interrupt raw status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ERRORINTRAWSTAT</name>
	<description>Error interrupt raw status
0: No Error interrupt.
1: An Error interrupt is pending. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTINTRAWSTAT</name>
	<description>Encryption engine interrupt raw status
0: No Encryption / Decryption interrupt.
1: An Encryption / Decryption interrupt is pending. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTINTRAWSTAT</name>
	<description>End of Event interrupt raw status
0: No End of Advertising / Scanning / Connection interrupt.
1: An End of Advertising / Scanning / Connection interrupt is pending. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLPINTRAWSTAT</name>
	<description>Sleep interrupt raw status
0: No End of Sleep Mode interrupt.
1: An End of Sleep Mode interrupt is pending. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXINTRAWSTAT</name>
	<description>Packet Reception interrupt raw status
0: No Rx interrupt.
1: An Rx interrupt is pending. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CSCNTINTRAWSTAT</name>
	<description>625us base time reference interrupt raw status
0: No 625us Base Time interrupt.
1: A 625us Base Time interrupt is pending. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_INTSTAT_REG</name>
	<description>Interrupt status register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SWINTSTAT</name>
	<description>SW triggered interrupt status
0: No SW triggered interrupt.
1: A SW triggered interrupt is pending </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTAPFAINTSTAT</name>
	<description>End of event / Anticipated Pre-Fetch Abort interrupt status
0: No End of Event interrupt.
1: An End of Event interrupt is pending. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FINETGTIMINTSTAT</name>
	<description>Masked Fine Target Timer Error interrupt status
0: No Fine Target Timer interrupt.
1: A Fine Target Timer interrupt is pending. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GROSSTGTIMINTSTAT</name>
	<description>Masked Gross Target Timer interrupt status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ERRORINTSTAT</name>
	<description>Masked Error interrupt status
0: No Error interrupt.
1: An Error interrupt is pending. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTINTSTAT</name>
	<description>Masked Encryption engine interrupt status
0: No Encryption / Decryption interrupt.
1: An Encryption / Decryption interrupt is pending. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTINTSTAT</name>
	<description>Masked End of Event interrupt status
0: No End of Advertising / Scanning / Connection interrupt.
1: An End of Advertising / Scanning / Connection interrupt is pending. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLPINTSTAT</name>
	<description>Masked Sleep interrupt status
0: No End of Sleep Mode interrupt.
1: An End of Sleep Mode interrupt is pending. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXINTSTAT</name>
	<description>Masked Packet Reception interrupt status
0: No Rx interrupt.
1: An Rx interrupt is pending. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CSCNTINTSTAT</name>
	<description>Masked 625us base time reference interrupt status
0: No 625us Base Time interrupt.
1: A 625us Base Time interrupt is pending. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RADIOCNTL0_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x7fffffff</resetMask>
	
</register><register>
	<name>BLE_RADIOCNTL1_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XRFSEL</name>
	<description>Extended radio selection field, Must be set to &quot;2&quot;.</description>
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RADIOCNTL2_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	
</register><register>
	<name>BLE_RADIOCNTL3_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x7fffffff</resetMask>
	
</register><register>
	<name>BLE_RADIOPWRUPDN_REG</name>
	<description>RX/TX power up/down phase register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00d203d2</resetValue>
	<resetMask>0x7fff0fff</resetMask>
	<fields><field>
	<name>RTRIP_DELAY</name>
	<description>Defines round trip delay value. This value correspond to the addition of data latency in Tx and data latency in Rx. Value is in usec.</description>
	<bitRange>[30:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXPWRUP</name>
	<description>This register holds the length in s of the RX power up phase for the current radio device. Default value is 210 usec (reset value). Operating range depends on the selected radio. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPWRDN</name>
	<description>This register extends the length in s of the TX power down phase for the current radio device. Default value is 3 usec (reset value). Operating range depends on the selected radio. </description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPWRUP</name>
	<description>This register holds the length in s of the TX power up phase for the current radio device. Default value is 210 usec (reset value). Operating range depends on the selected radio. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RFTESTCNTL_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>INFINITERX</name>
	<description>Applicable in RF Test Mode only
0: Normal mode of operation
1: Infinite Rx window </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXPKTCNTEN</name>
	<description>Applicable in RF Test Mode only
0: Rx packet count disabled
1: Rx packet count enabled, and reported in CS-RXCCMPKTCNT and RFTESTRXSTAT-RXPKTCNT on RF abort command </description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INFINITETX</name>
	<description>Applicable in RF Test Mode only
0: Normal mode of operation.
1: Infinite Tx packet / Normal start of a packet but endless payload </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXLENGTHSRC</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Normal mode of operation: TxDESC-TXADVLEN controls the Tx packet payload size
1: Uses RFTESTCNTL-TXLENGTH packet length (can support up to 512 bytes transmit) </description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRBSTYPE</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Tx Packet Payload are PRBS9 type
1: Tx Packet Payload are PRBS15 type </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPLDSRC</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Tx Packet Payload source is the Control Structure
1: Tx Packet Payload are PRBS generator </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPKTCNTEN</name>
	<description>Applicable in RF Test Mode only
0: Tx packet count disabled
1: Tx packet count enabled, and reported in CS-TXCCMPKTCNT and RFTESTTXSTAT-TXPKTCNT on RF abort command </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXLENGTH</name>
	<description>Applicable only for Tx/Rx RF Test mode, and valid when RFTESTCNTL-TXLENGTHSRC = 1
Tx packet length in number of byte </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RFTESTRXSTAT_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXPKTCNT</name>
	<description>Reports number of correctly received packet during Test Modes (no sync error, no CRC error).
Value is valid if RFTESTCNTL-RXPKTCNTEN is set</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RFTESTTXSTAT_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXPKTCNT</name>
	<description>Reports number of transmitted packet during Test Modes.
Value is valid if RFTESTCNTL-TXPKTCNTEN is set</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RWBLECNTL_REG</name>
	<description>BLE Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MASTER_SOFT_RST</name>
	<description>Reset the complete BLE Core except registers and timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[31:31]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>MASTER_TGSOFT_RST</name>
	<description>Reset the timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[30:30]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>REG_SOFT_RST</name>
	<description>Reset the complete register block, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.
Note that INT STAT will not be cleared, so the user should also write to BLE_INTACK_REG after the SW Reset</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWINT_REQ</name>
	<description>Forces the generation of ble_sw_irq when written with a 1, and proper masking is set. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[28:28]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RFTEST_ABORT</name>
	<description>Abort the current RF Testing defined as per CS-FORMAT when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.
Note that when RFTEST_ABORT is requested:
1) In case of infinite Tx, the Packet Controller FSM stops at the end of the current byte in process, and processes accordingly the packet CRC.
2) In case of Infinite Rx, the Packet Controller FSM either stops as the end of the current Packet reception (if Access address has been detected), or simply stop the processing switching off the RF.</description>
	<bitRange>[26:26]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>ADVERT_ABORT</name>
	<description>Abort the current Advertising event when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[25:25]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SCAN_ABORT</name>
	<description>Abort the current scan window when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[24:24]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>MD_DSB</name>
	<description>0: Normal operation of MD bits management
1: Allow a single Tx/Rx exchange whatever the MD bits are.
value forced by SW from Tx Descriptorvalue just saved in Rx Descriptor during reception</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SN_DSB</name>
	<description>0: Normal operation of Sequence number
1: Sequence Number Management disabled:
value forced by SW from Tx Descriptorvalue ignored in Rx, where no SN error reported.</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NESN_DSB</name>
	<description>0: Normal operation of Acknowledge
1: Acknowledge scheme disabled:
value forced by SW from Tx Descriptorvalue ignored in Rx, where no NESN error reported.</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPT_DSB</name>
	<description>0: Normal operation. Encryption / Decryption enabled.
1: Encryption / Decryption disabled.
Note that if CS-CRYPT_EN is set, then MIC is generated, and only data encryption is disabled, meaning data sent are plain data.</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WHIT_DSB</name>
	<description>0: Normal operation. Whitening enabled.
1: Whitening disabled.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRC_DSB</name>
	<description>0: Normal operation. CRC removed from data stream.
1: CRC stripping disabled on Rx packets, CRC replaced by 0x000 in Tx.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HOP_REMAP_DSB</name>
	<description>0: Normal operation. Frequency Hopping Remapping algorithm enabled.
1: Frequency Hopping Remapping algorithm disabled</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADVERTFILT_EN</name>
	<description>Advertising Channels Error Filtering Enable control
0: RW-BLE Core reports all errors to RW-BLE Software
1: RW-BLE Core reports only correctly received packet, without error to RW-BLE Software</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RWBLE_EN</name>
	<description>0: Disable RW-BLE Core Exchange Table pre-fetch mechanism.
1: Enable RW-BLE Core Exchange table pre-fetch mechanism.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXWINSZDEF</name>
	<description>Default Rx Window size in us. Used when device:

is master connectedperforms its second receipt.0 is not a valid value. Recommended value is 10 (in decimal).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYNCERR</name>
	<description>Indicates the maximum number of errors allowed to recognize the synchronization word.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RWBLECONF_REG</name>
	<description>Configuration register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0f02001f</resetValue>
	<resetMask>0x3f7f3f7f</resetMask>
	<fields><field>
	<name>ADD_WIDTH</name>
	<description>Value of the RW_BLE_ADDRESS_WIDTH parameter concerted into binary.</description>
	<bitRange>[29:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFIF</name>
	<description>Radio Interface ID </description>
	<bitRange>[22:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_SEL</name>
	<description>Operating Frequency (in MHz) </description>
	<bitRange>[13:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DECIPHER</name>
	<description>0: AES deciphering not present</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMMODE</name>
	<description>0: RW-BLE Core is used as a standalone BLE device </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>INTMODE</name>
	<description>1: Interrupts are trigger level generated, i.e. stays active at 1 till acknowledgement </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COEX</name>
	<description>1: WLAN Coexistence mechanism present </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USEDBG</name>
	<description>1: Diagnostic port instantiated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USECRYPT</name>
	<description>1: AES-CCM Encryption block present </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSWIDTH</name>
	<description>Processor bus width:
1: 32 bits </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RXMICVAL_REG</name>
	<description>AES / CCM plain MIC value</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXMICVAL</name>
	<description>AES-CCM plain MIC value. Valid on once MIC has been extracted from Rx packet. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_SAMPLECLK_REG</name>
	<description>Samples the Base Time Counter</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SAMP</name>
	<description>Writing a 1 samples the Base Time Counter value in BASETIMECNT register. Resets at 0 when action is performed. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>BLE_SWPROFILING_REG</name>
	<description>Software Profiling register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SWPROFVAL</name>
	<description>Software Profiling register: used by RW-BLE Software for profiling purpose: this value is copied on Diagnostic port </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_TIMGENCNTL_REG</name>
	<description>Timing Generator Register</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>APFM_EN</name>
	<description>Controls the Anticipated pre-Fetch Abort mechanism
0: Disabled
1: Enabled </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PREFETCHABORT_TIME</name>
	<description>Defines the instant in usec at which immediate abort is required after anticipated pre-fetch abort.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PREFETCH_TIME</name>
	<description>Defines Exchange Table pre-fetch instant in us </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_TXMICVAL_REG</name>
	<description>AES / CCM plain MIC value</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXMICVAL</name>
	<description>AES-CCM plain MIC value. Valid on when MIC has been calculated (in Tx) </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_VERSION_REG</name>
	<description>Version register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07010000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TYP</name>
	<description>BLE Core Type</description>
	<bitRange>[31:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>REL</name>
	<description>BLE Core version Major release number.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UPG</name>
	<description>BLE Core upgrade Upgrade number.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUILD</name>
	<description>BLE Core Build Build number.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_WLNBDEV_REG</name>
	<description>Devices in white list</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>NBPRIVDEV</name>
	<description>Number of private devices in the white list.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NBPUBDEV</name>
	<description>Number of public devices in the white list. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_WLPRIVADDPTR_REG</name>
	<description>Start address of private devices list</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WLPRIVADDPTR</name>
	<description>Start address pointer of the private devices white list. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_WLPUBADDPTR_REG</name>
	<description>Start address of public devices list</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WLPUBADDPTR</name>
	<description>Start address pointer of the public devices white list. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CHIP_VERSION</name>
	<version>1.0</version>
	<description>CHIP_VERSION registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>254</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CHIP_ID1_REG</name>
	<description>Chip identification register 1.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID1</name>
	<description>First character of device type &quot;2632&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID2_REG</name>
	<description>Chip identification register 2.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000036</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID2</name>
	<description>Second character of device type &quot;2632&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID3_REG</name>
	<description>Chip identification register 3.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000033</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID3</name>
	<description>Third character of device type &quot;2632&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID4_REG</name>
	<description>Chip identification register 4.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID4</name>
	<description>Fourth character of device type &quot;2632&quot; in ASCII.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_REVISION_REG</name>
	<description>Chip revision register.</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_REVISION</name>
	<description>Chip version, corresponds with type number in ASCII.
0x41 = 'A', 0x42 = 'B' </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_SWC_REG</name>
	<description>Software compatibility register.</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>CHIP_SWC</name>
	<description>SoftWare Compatibility code.
Integer (default = 0) which is incremented if a silicon change has impact on the CPU Firmware.
Can be used by software developers to write silicon revision dependent code. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_TEST1_REG</name>
	<description>Chip test register 1.</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_LAYOUT_REVISION</name>
	<description>Chip layout revision, corresponds with type number in ASCII.
0x41 = 'A', 0x42 = 'B' </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_TEST2_REG</name>
	<description>Chip test register 2.</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>CHIP_METAL_OPTION</name>
	<description>Chip metal option value.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_AON</name>
	<version>1.0</version>
	<description>CRG_AON registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>242</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GP_DATA_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>ANA_SPARE</name>
	
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DISABLE_CLAMP_OVERRULE</name>
	<description>0: VDD Clamp setting is overruled when ldo_core is enabled.
1: VDD Clamp setting is not overruled</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_GP_DATA</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>HIBERN_CTRL_REG</name>
	<description>Hibernation control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>HIBERN_WKUP_MASK</name>
	<description>Selects which pin to wakeup from</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HIBERN_WKUP_POLARITY</name>
	<description>Selects the polarity of the wakeup source. The polarity must be chosen such that the ANA_STATUS_REG[CLKLESS_WAKEUP_STAT] is '1'. Any change on the selected GPIOs will make the CLKLESS_WAKEUP_STAT go to '0', and wakeup the system from hibernation.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HIBERNATION_ENABLE</name>
	<description>Enables the hibernation mode when sleeping
0: deep sleep mode, PD_SLP remains on
1: hibernation mode, PD_SLP goes off. REMAP_ADR0 needs to be set to the correct source to boot from before going to sleep.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>HWR_CTRL_REG</name>
	<description>Hardware Reset control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>DISABLE_HWR</name>
	<description>Disables the RST functionality on P00</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>PAD_LATCH_EN</name>
	<description>Direct write to the pad_latch_enable signal</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_AON_CTRL_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>FORCE_RUNNING_COMP_DIS</name>
	<description>Disable the testmode comparator</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RET_TRIM</name>
	<description>Level setting for VDD when using clamp
Typical output voltages (not regulated):
0x0: 1154 mV
0x1: 1123 mV
0x2: 1093 mV
0x3: 1064 mV
0x4: 1057 mV
0x5: 1030 mV
0x6: 1005 mV
0x7: 974 mV
0x8: 961 mV
0x9: 928 mV
0xA: 900 mV
0xB: 872 mV
0xC: 803 mV
0xD: 770 mV
0xE: 740 mV
0xF: 603 mV (changed to be lower than ldo_core_ret level)</description>
	<bitRange>[13:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMP_VCONT_SLP_DISABLE</name>
	<description>Disable vcont comparator in SLP</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_MODE_FORCE</name>
	<description>0x:automatic selection of boost mode
11: force boost mode
10: force buck mode</description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGE_VBAT_DISABLE</name>
	<description>Do not charge vbat high in boost mode</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_LOW_SPEED_FORCE</name>
	<description>Forces rc32k in 32kHz mode, this bit has priority over the RC32K_HIGH_SPEED_FORCE setting. When RC32K_HIGH_SPEED_FORCE=0 and RC32K_LOW_SPEED_FORCE=0 the frequency will be 512kHz in RUNNING and 32kHz in SLEEP.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_HIGH_SPEED_FORCE</name>
	<description>Forces rc32k in 512kHz mode
0: frequency is 512kHz in RUNNING and 32kHz in SLP
1: frequency is 512kHz</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_HIGH_RST_MASK</name>
	<description>Mask rst from por_vbat_high</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_LOW_RST_MASK</name>
	<description>Mask rst from por_vbat_low</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBAT_HL_CONNECT_RES_CTRL</name>
	<description>00: OFF
01: Forced ON
10: Active: automatic control, Sleep: forced ON
11: Automatic control</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RAM_LPMX_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>RAMx_LPMX</name>
	<description>RAM[3:1] Transparent Light Sleep (TLS) Core Enable. Assert low to enable the TLS core feature, which will result in lower leakage current.
In case VDD is lowered below nominal-10%, it may be necessary to hold this pin high to maintain data retention.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_STAT_REG</name>
	<description>Reset status register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>WDOGRESET_STAT</name>
	<description>Indicates that a Watchdog has happened.
This bit is also set with a PowerOn Reset</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWRESET_STAT</name>
	<description>Indicates that a SW Reset has been requested.
The SW reset is requested by SYS_CTRL_REG[SW_RESET] or SCB-&gt;AIRCR inside the ARM.
This bit is also set with a PowerOn Reset</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HWRESET_STAT</name>
	<description>Indicates that a HW Reset has happened
This bit is also set with a PowerOn Reset</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PORESET_STAT</name>
	<description>Indicates that a PowerOn Reset has happened</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TEST_VDD_REG</name>
	
	<addressOffset>0x000000f0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>LDOS_DISABLE</name>
	<description>Disable LDOs</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TEST_VDD</name>
	<description>Enables NMOS switch from VDD to P01, to measure and apply VDD externally.
Note: Switch is more low-ohmic when VBAT_HIGH has higher value, VBAT_HIGH=3V --&gt; RON_SW=~3W </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_TIM</name>
	<version>1.0</version>
	<description>CRG_TIM registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50004200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>80</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_RTCDIV_REG</name>
	<description>Divisor for RTC 100Hz clock</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00051ea8</resetValue>
	<resetMask>0x003fffff</resetMask>
	<fields><field>
	<name>RTC_RESET_REQ</name>
	<description>Reset request for the RTC module</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_ENABLE</name>
	<description>Enable for the 100 Hz generation for the RTC block</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_DENOM</name>
	<description>Selects the denominator for the fractional division:
0b0: 1000
0b1: 1024</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_INT</name>
	<description>Integer divisor part for RTC 100Hz generation</description>
	<bitRange>[18:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_FRAC</name>
	<description>Fractional divisor part for RTC 100Hz generation.
if RTC_DIV_DENOM=1, &lt;RTC_DIV_FRAC&gt; out of 1024 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;
If RTC_DIV_DENOM=0, &lt;RTC_DIV_FRAC&gt; out of 1000 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_TOP</name>
	<version>1.0</version>
	<description>CRG_TOP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>86</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>ANA_STATUS_REG</name>
	<description>Status bit of analog (power management) circuits</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>CLKLESS_WAKEUP_STAT</name>
	<description>Indicates the output of the Clockless wakeup XOR tree. If this signal is '0', the chip will wake up.
Use the HIBERN_WKUP_POLARITY bit to set the value to '1' before going into hibernation mode.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FORCE_RUNNING</name>
	<description>Output of force running comparator </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_GPADC_OK</name>
	<description>Indicates that LDO_GPADC output is OK </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_XTAL_OK</name>
	<description>Indicates that LDO_XTAL output is OK </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_SELECTED</name>
	<description>0: Buck mode detected
1: Boost mode detected</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>POR_VBAT_HIGH</name>
	<description>Output of VBAT_HIGH supply rail voltage monitoring circuit.
0: Voltage level on VBAT_HIGH is lower than POR VBAT_HIGH threshold VTH_L (rail not ok, will result in reset if not masked)
1: Voltage level on VBAT_HIGH is higher than POR VBAT_HIGH threshold VTH_H (rail ok, reset released) </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>POR_VBAT_LOW</name>
	<description>Output of VBAT_LOW supply rail voltage monitoring circuit.
0: Voltage level on VBAT_LOW is lower than POR VBAT_LOW threshold VTH_L (rail not ok, will result in reset if not masked)
1: Voltage level on VBAT_LOW is higher than POR VBAT_LOW threshold VTH_H (rail ok, reset released) </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BANDGAP_OK</name>
	<description>Indicates that BANDGAP is OK </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBAT_HIGH_NOK</name>
	<description>Indicates that VBAT_HIGH &lt; VBAT_LOW -50 mV </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBAT_HIGH_OK</name>
	<description>Indicates that VBAT_HIGH &gt; VBAT_LOW +50 mV </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_OK</name>
	<description>Indicates that VBAT_LOW (buck mode) or VBAT_HIGH (boost mode) is OK </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_LOW_OK</name>
	<description>Indicates that LDO_LOW output is OK
(only valid for high current mode) </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_CORE_OK</name>
	<description>Indicates that LDO_CORE output is OK </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BANDGAP_REG</name>
	<description>Bandgap trimming</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>BGR_ITRIM</name>
	<description>Trim setting for bandgap bias current
10000 -&gt; -25%
....
11111 -&gt; ~0%
00000 -&gt; ~0% (typ)
...
01111 -&gt; +32%</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGR_TRIM</name>
	<description>Trim setting for bandgap voltage
10000 -&gt; -6.4%
....
11111 -&gt; ~0%
00000 -&gt; ~0% (typ)
...
01111 -&gt; +5.8%</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_AMBA_REG</name>
	<description>HCLK, PCLK, divider and clock gates</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>OTP_ENABLE</name>
	<description>Clock enable for OTP controller </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCLK_DIV</name>
	<description>APB interface clock (PCLK). Divider is cascaded with HCLK_DIV. PCLK is HCLK divided by:
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HCLK_DIV</name>
	<description>AHB interface and microprocessor clock (HCLK). HCLK is source clock divided by:
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_CTRL_REG</name>
	<description>Clock control register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>RUNNING_AT_XTAL32M</name>
	<description>Indicates that the XTAL32M clock is used as clock, and may not be switched off </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_RC32M</name>
	<description>Indicates that the RC32M clock is used as clock </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_LP_CLK</name>
	<description>Indicates that either the LP_CLK is being used as system clock </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LP_CLK_SEL</name>
	<description>Sets the clock source of the LowerPower clock
0x0: RC32K
0x1: RCX
0x2: XTAL32K through the oscillator with an external Crystal.
0x3: XTAL32K through an external square wave generator (set PID of P0[3] to FUNC_GPIO)
Change this setting before using this clock, and while RUNNING_AT_LP_CLK == 0.</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_DISABLE</name>
	<description>Setting this bit instantaneously disables the 32 MHz crystal oscillator. Also, after sleep/wakeup cycle, the oscillator will not be enabled. This bit may not be set to '1'when &quot;RUNNING_AT_XTAL32M is '1' to prevent deadlock. After resetting this bit, wait for XTAL32M_SETTLED or XTAL32M_TRIM_READY to become '1' before switching to XTAL32M clock source. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CLK_SEL</name>
	<description>Selects the clock source.
0x0: XTAL32M (check the XTAL32M_SETTLED and XTAL32M_TRIM_READY bits!!)
0x1: RC32M
0x2/0x3: LP_CL</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_FREQ_TRIM_REG</name>
	<description>Xtal frequency trimming register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTAL32M_TRIM</name>
	<description>Xtal frequency fine trimming register.
0x00: highest frequency
0xFF: lowest frequency </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_PER_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000800</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>QUAD_ENABLE</name>
	<description>Enable the Quadrature clock </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enable SPI clock </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART1_ENABLE</name>
	<description>Enable UART1 clock </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enable UART2 clock </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enable I2C clock </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUPCT_ENABLE</name>
	<description>Enable Wakeup CaptureTimer clock </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_ENABLE</name>
	<description>Enable TIMER0 and TIMER2 clock </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_DIV</name>
	<description>Division factor for TIMER0
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RADIO_REG</name>
	<description>Radio PLL control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BLE_ENABLE</name>
	<description>Enable the BLE core clocks </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_LP_RESET</name>
	<description>Reset for the BLE LP timer </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_DIV</name>
	<description>Division factor for BLE core blocks
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8
The programmed frequency should not be lower than 8 MHz and not faster than the programmed CPU clock frequency. Refer also to BLE_CNTL2_REG[BLE_CLK_SEL].</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCU_ENABLE</name>
	<description>Enable the RF control Unit clock </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RC32K_REG</name>
	<description>32 kHz RC oscillator register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000e</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>RC32K_TRIM</name>
	<description>0000 = lowest frequency
0111 = default
1111 = highest frequency </description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_DISABLE</name>
	<description>Instantly disables the 32kHz RC oscillator
Sleep cycles cannot happen with this clock disabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RC32M_REG</name>
	<description>Fast RC control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000078e</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>RC32M_COSC</name>
	<description>C-adjust of RC-oscillator
A higher value of COSC results in a lower frequency</description>
	<bitRange>[10:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_RANGE</name>
	<description>Coarse adjust
A higher value of RANGE results in a higher frequency, values 2 and 3 are equal</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_BIAS</name>
	<description>Bias adjustment</description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_DISABLE</name>
	<description>Instantly disables the 32MHz RC oscillator
Disabling of the oscillator during sleep happens automatically.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RCX_REG</name>
	<description>RCX-oscillator control register</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000afc</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>RCX_BIAS</name>
	<description>LDO bias current.
0x0: minimum
0xF: maximum</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_C0</name>
	<description>Add unit capacitance to RC-time delay.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_CADJUST</name>
	<description>Adjust capacitance part of RC-time delay.
0x00: minimum capacitance
0x1F: maximum capacitance</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_RADJUST</name>
	<description>Adjust resistance part of RC-time delay. Lower resistance increases power consumption.
0x0: maximum resistance
0x1: minimum resistance</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_ENABLE</name>
	<description>Enable the RCX oscillator</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_XTAL32K_REG</name>
	<description>32 kHz XTAL oscillator register</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000002e</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>XTAL32K_XTAL1_BIAS_DISABLE</name>
	<description>Disables the 1nA bias current through the pull down diode</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_DISABLE_AMPREG</name>
	<description>Setting this bit disables the amplitude regulation of the XTAL32kHz oscillator.
Set this bit to '1' for an external clock to XTAL32Kp
Keep this bit '0' with a crystal between XTAL32Kp and XTAL32Km</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_CUR</name>
	<description>Bias current for the 32kHz XTAL oscillator. 0000 is minimum, 1111 is maximum, 0011 is default. For each application there is an optimal setting for which the start-up behavior is optimal </description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_RBIAS</name>
	<description>Setting for the bias resistor. 00 is maximum, 11 is minimum. Prefered setting will be provided by Dialog </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_ENABLE</name>
	<description>Enables the 32kHz XTAL oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_CTRL_REG</name>
	<description>Power Management Unit control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>MAP_BANDGAP_EN</name>
	<description>Enable wakeup diagnostics mapping. When set, these functions are mapped (please set direction to output)
P0[2]: BANDGAP_ENABLE
P0[1]: Power WOKENUP
Note: P0[2] assigned also to SWD_CLK, thus the debugger must be detached before entering into sleep mode with MAP_BANDGAP_EN=1. Refer also to SYS_STAT_REG-&gt;DBG_IS_UP.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTP_COPY_DIV</name>
	<description>Sets the HCLK division during OTP mirroring </description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_SLEEP</name>
	<description>Put the digital part of the radio in powerdown </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SLEEP</name>
	<description>Put PD_TIM in powerdown </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_ON_WAKEUP</name>
	<description>Perform a Hardware Reset after waking up. Booter will be started. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_SLEEP_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000080</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>BG_REFRESH_INTERVAL</name>
	<description>This is a value defining the interval every which the Bandgap will be activated for refresh. The value represents ticks of rc32k_clk/64 e.g. 30,5 us * 64 = 1,9 ms.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_PIN_REG</name>
	<description>Selects a GPIO pin for POR generation</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>POR_PIN_POLARITY</name>
	<description>0: Active Low
1: Active High
Note: This applies only for the GPIO pin. Reset pad has a fixed polarity
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_PIN_SELECT</name>
	<description>Selects the GPIO which is used for POR generation.
0x0: GPIO pin POReset disabled
0x1: P0_0
0x2: P0_1
...
0xB: P0_10
0xC: P0_11
0xD - 0xF: reserved</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_TIMER_REG</name>
	<description>Time for POR to happen</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000018</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>POR_TIME</name>
	<description>Time for the POReset to happen.
Formula:
Time = POR_TIME x 4096 x RC32k clock period
Default value: ~3 seconds
When set to 0x00, the POR TIMER is disabled.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_CTRL_REG</name>
	
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VBAT_HL_CONNECT_MODE</name>
	<description>Sets the control mode fo the switch between VBAT_HIGH and VBAT_LOW
0: Manual (default)
1: Automatic (boost mode only)</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_HIGH_HYST_DIS</name>
	<description>0: Hysteresis enabled
1: Hysteresis disabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_HIGH_HYST_SEL</name>
	<description>0: Low level selected
1: High level selected</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_HIGH_DISABLE</name>
	<description>Disable por_vbat_high circuit</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_LOW_HYST_DIS</name>
	<description>0: Hysteresis enabled
1: Hysteresis disabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_LOW_HYST_SEL</name>
	<description>0: Low level selected
1: High level selected</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_LOW_DISABLE</name>
	<description>Disable por_vbat_low circuit</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CP_DISABLE</name>
	<description>Disables LDO_CORE charge-pump circuit</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VREF_HOLD_FORCE</name>
	<description>Forces LDO references in HOLD mode
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_LOW_CTRL_REG</name>
	<description>00: High-current mode in active, LDO_LOW OFF in sleep
01: LDO_LOW OFF
10: Low-current mode in active, Low-current mode in sleep
11: High-current mode in active, Low-current mode in sleep</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_DISABLE</name>
	<description>Disables LDO_CORE</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_RET_ENABLE</name>
	<description>LDO_CORE_RETENTION
0: Disabled
1: Enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBAT_HL_CONNECT</name>
	<description>Switch between VBAT_HIGH and VBAT_LOW
0: Open
1: Closed</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMP_VBAT_HIGH_OK_ENABLE</name>
	<description>Enable cmp_vbat_high_ok</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMP_VBAT_HIGH_NOK_ENABLE</name>
	<description>Enable cmp_vbat_high_nok</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_LEVEL_REG</name>
	
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001a3e</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>DCDC_TRIM</name>
	<description>Delta from DCDC_LEVEL nominal value
000: -75 mV
001: -50 mV
010: -25 mV
011: 0 (default)
100: +25 mV
101: +50 mV
110: +75 mV
111: +100 mV</description>
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_LEVEL</name>
	<description>00: 1.1 V
01: 1.8 V (default)
10: 2.5 V
11: 3.0 V</description>
	<bitRange>[10:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_RET_CUR_TRIM</name>
	<description>00: Default value
01: 2x error amp tail current
10: 2xadaptive bias feedback ratio
11: 2x both tail current and adaptive bias feedback ratio </description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_XTAL_TRIM</name>
	<description>Delta from 0.9 V nominal value
000: -75 mV
001: -50 mV
010: -25 mV
011: 0 (default)
100: +25 mV
101: +50 mV
110: +75 mV
111: +100 mV</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_LOW_TRIM</name>
	<description>Delta from 1.1 V nominal value
000: -75 mV
001: -50 mV
010: -25 mV
011: 0 (default)
100: +25 mV
101: +50 mV
110: +75 mV
111: +100 mV (coldboot)</description>
	<bitRange>[3:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_LEVEL</name>
	<description>0: 0.9V
1: 1.0V (testmode, do not use)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RAM_PWR_CTRL_REG</name>
	<description>Control power state of System RAMS</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RAM3_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM2_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM1_PWR_CTRL</name>
	<description>Power state control of the individual RAMs. May only change when the memory isn't accessed.
When PD_SYS_IS_UP:
0x0: Normal operation
0x1: Normal operation
0x2: Retained (no access possible)
0x3: Off (memory content corrupted)
When PD_MEM_IS_DOWN:
0x0: Retained
0x1: Off (memory content corrupted)
0x2: Retained
0x3: Off (memory content corrupted)</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_CTRL_REG</name>
	<description>System Control register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x000087ff</resetMask>
	<fields><field>
	<name>SW_RESET</name>
	<description>Writing a '1' to this bit will reset the device, except for:
SYS_CTRL_REG
CLK_FREQ_TRIM_REG
... </description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TIMEOUT_DISABLE</name>
	<description>Disables timeout in Power statemachine. By default, the statemachine continues if after 2 ms the blocks are not started up. This can be read back from
ANA_STATUS_REG. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEBUGGER_ENABLE</name>
	<description>Enable the debugger. This bit is set by the booter according to the OTP header. If not set, the SWDIO and SW_CLK can be used as gpio ports.
0x0: no debugger enabled.
0x1: SW_CLK = P0[2], SW_DIO=P0[5]
0x2: SW_CLK = P0[2], SW_DIO=P0[1]
0x3: SW_CLK = P0[2], SW_DIO=P0[10]</description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_RESET_REQ</name>
	<description>Reset request for the OTP controller. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTP_COPY</name>
	<description>Enables OTP to SysRAM copy action after waking up PD_SYS </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_PHASE</name>
	<description>Sets the development phase mode.

If this bit is set, in combination with the OTP_COPY bit, the OTP DMA will emulate the OTP mirroring to System RAM.
No actual writing to RAM is done, but the exact same amount of time is spend as if the mirroring would take place. This is to mimic the behavior as if the System Code is already in OTP, and the mirroring takes place after waking up, but the (development) code still resides in an external source.
If this bit is set to '0' and OTP_COPY='1', then the OTP DMA will actually do the OTP mirroring at wakeup.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REMAP_ADR0</name>
	<description>Controls which memory is located at address 0x0000 for execution.
0x0: ROM
0x1: OTP
0x2: RAM (SysRAM1)
0x3: RAM (SysRAM3, 28 kBytes offset)
This bitfield only takes affect after a Software Reset.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_STAT_REG</name>
	<description>System status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000045</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTAL32M_SETTLED</name>
	<description>Indicates that XTAL32M has had its settle time, as defined by TRIM_CTRL_REG[XTAL_SETTLE_N]</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_TRIM_READY</name>
	<description>Indicates that XTAL trimming mechanism is ready, i.e. the trimming equals CLK_FREQ_TRIM_REG. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBG_IS_UP</name>
	<description>Indicates that the SW debugger is attached and in connection with the ARM.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_UP</name>
	<description>Indicates that PD_TIM is functional </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_DOWN</name>
	<description>Indicates that PD_TIM is in power down </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_UP</name>
	<description>Indicates that PD_RAD is functional </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_DOWN</name>
	<description>Indicates that PD_RAD is in power down </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TRIM_CTRL_REG</name>
	<description>Control trimming of the XTAL32M</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003f22</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>XTAL_SETTLE_N</name>
	<description>Designates that the XTAL can be safely used as the CPU clock. When XTAL_CLK_CNT reases this value, the signal XTAL32M_SETTLED bit in the SYS_STAT_REG will be set. Counts in steps of 64 xtal clock-cycles.</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL_TRIM_SELECT</name>
	<description>Select which source controls the XTAL trimming
0b00: xtal counter. Starts CLK_FREQ_TRIM_REG[XTAL32M_START] after COUNT_N * 32 xtal pulses trim is changed to CLK_FREQ_TRIM_REG[XTAL32M_TRIM].
0b01: xtal OK filter. Starts with CLK_FREQ_TRIM_REG[XTAL32M_START], when xtal is ramping is changed to CLK_FREQ_TRIM_REG[XTAL32M_TRIM].
0b10: statically forced off. Only uses CLK_FREQ_TRIM_REG[XTAL32M_TRIM].
0b11: xtal OK filter, 2 stage. Starts with CLK_FREQ_TRIM_REG[XTAL32M_START] switches to CLK_FREQ_TRIM_REG[XTAL32M_RAMP] after timeout (sw1='1', XTAL32M_CTRL0_REG[XTAL32M_SW_DELAY]), and switches to CLK_FREQ_TRIM_REG[XTAL32M_TRIM] when sw2='1'.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL_COUNT_N</name>
	<description>Defines the number of XTAL cycles to be counted, before the xtal trimming is applied, in steps of 64 cycles.
0x01: 64
0x02: 128
0x3f: 4032</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CTRL0_REG</name>
	<description>Control bits for XTAL32M</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000015</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>XTAL32M_SPARE</name>
	<description>Spare register</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_AMPL_TRIM</name>
	<description>Core amplitude trimming</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_CUR_SET</name>
	<description>Core current trim setting</description>
	<bitRange>[4:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_AMPL_REG_NULLBIAS</name>
	<description>Keep bias in ampl detector alive, even when there is a large drive</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCBLOCK_ENABLE</name>
	<description>Enable dcblock/high pass filter circuit</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_START_REG</name>
	<description>Trim values for XTAL32M</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000aa</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL32M_RAMP</name>
	<description>Xtal frequency trimming register.
0x00 : highest frequency
0xFF :lowest frequency</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_START</name>
	<description>Xtal frequency trimming register.
0x0 = highest frequency
0xF = lowest frequency.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_TRSTAT_REG</name>
	<description>Read back value of current XTAL trimming</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTAL32M_TRSTAT</name>
	<description>Reads value of the current XTAL trimming</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>XTALRDY_CTRL_REG</name>
	<description>Control register for XTALRDY IRQ</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTALRDY_CNT</name>
	<description>Number of 32kHz or 256kHz cycles between the crystal is enabled, and the XTALRDY_IRQ is fired. Frequency set by XTALRDY_CLK_SEL.
0x00: no interrupt
</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTALRDY_STAT_REG</name>
	<description>Difference between XTAL_OK and XTALRDY_IRQ in LP clock cycles</description>
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTALRDY_STAT</name>
	<description>Value of IRQ counter when trimming is switched from RAMP to TRIM</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DCDC</name>
	<version>1.0</version>
	<description>DCDC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000080</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>10</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DCDC_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000084a2</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DCDC_ILIM_MAX</name>
	<description>Maximum value for automatic inductor peak current limit control.
0x0: 6 mA
0x1: 12 mA
0x2: 18 mA
0x3: 24 mA
0x4: 30 mA
0x5: 36 mA
0x6: 42 mA
0x7: 48 mA
0x8: 54 mA (default, limits inrush current)
0x9: 60 mA
0xA: 66 mA
0xB: 72 mA
0xC: 78 mA
0xD: 84 mA
0xE: 90 mA
0xF: 96 mA (set as default for low-ohmic batteries)</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_ILIM_MIN</name>
	<description>Minimum value for automatic inductor peak current limit control.
0x0: 6 mA
0x1: 12 mA
0x2: 18 mA
0x3: 24 mA
0x4: 30 mA (default)
0x5: 36 mA
0x6: 42 mA
0x7: 48 mA
0x8: 54 mA
0x9: 60 mA
0xA: 66 mA
0xB: 72 mA
0xC: 78 mA
0xD: 84 mA
0xE: 90 mA
0xF: 96 mA</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_OK_CLR_CNT</name>
	<description>Number of subsequent V_NOK events needed to reset VDCD_OK.
0x0: 2
0x1: 4
0x2: 8 (deafult)
0x3: 15</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_TIMEOUT</name>
	<description>Switch timeout, go to next state if either switch is active for longer than this setting.
0x0: Disabled
0x1: 0.25 ms
0x2: 0.50 ms
0x3: 0.75 ms
0x4: 1.00 ms (default)
0x5: 1.25 ms
0x6: 1.50 ms
0x7: 1.75 ms</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_CLK_DIV</name>
	<description>Idle clock divider, sets rate at which the output is monitored when the converter is idle.
0x0: Divide by 4
0x1: Divide by 8
0x2: Divide by 16
0x3: Divide by 32</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_ENABLE</name>
	<description>Enables hardware control of the DCDC converter.
0: DCDC converter disabled
1: DCDC converter under hardware control</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCDC_STATUS1_REG</name>
	
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000048</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DCDC_FSM_STATE</name>
	<description>State of the analog FSM, only values listed below are valid:
0x0: Idle
0x1: Buck mode, PSW state
0x2: Buck mode, NSW state
0x4: Boost mode, PSW state
0x8: Boost mode, NSW state</description>
	<bitRange>[15:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_SW_STATE</name>
	<description>State of the DCDC switches:
0x0: Both switches open
0x1: P switch closed
0x2: N switch closed
0x3: Unused</description>
	<bitRange>[11:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_VOUT_NOK</name>
	<description>NOK signal from output comparator.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_VOUT_OK</name>
	<description>OK signal from output comparator.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_ILIM</name>
	<description>Actual inductor peak current limit.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_BOOST_MODE</name>
	<description>Indicates that the converter is in boost mode.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_STARTUP_COMPLETE</name>
	<description>Indicates that DCDC converter is enabled and startup delay of 4 ms has passed.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_ENABLED</name>
	<description>Value of the analog enable signal, depends on both register setting and external enable input.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_VDCDC_OK</name>
	<description>Becomes high if the output voltage is OK, resets after a programmable number of subsequent NOK events.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DCDC_STATUS2_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>DCDC_COMP_TRIM</name>
	<description>Actual comparator trim value.</description>
	<bitRange>[13:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_TIMEOUT_PSW</name>
	<description>Timeout signal for P switch.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_TIMEOUT_NSW</name>
	<description>Timeout signal for N switch.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_COMP_P_DYN_P</name>
	<description>P Output of P side dynamic comparator.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_COMP_P_DYN_N</name>
	<description>N Output of P side dynamic comparator.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_COMP_P_CONT</name>
	<description>Output of P side continuous time comparator.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_COMP_N_DYN_P</name>
	<description>P Output of N side dynamic comparator.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_COMP_N_DYN_N</name>
	<description>N Output of N side dynamic comparator.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_COMP_N_CONT</name>
	<description>Output of N side continuous time comparator.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DCDC_TEST1_REG</name>
	
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000400</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>DCDC_DIG_TST_SEL</name>
	<description>Controls digital test outputs.
0x0: Disabled (default)
0x1: Lower byte of DCDC_STATUS1_REG
0x2: Upper byte of DCDC_STATUS1_REG
0x3: Lower byte of DCDC_STATUS2_REG
0x4: Upper byte of DCDC_STATUS2_REG
0x5: Reserved
0x6: Reserved
0x7: Reserved</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_ILIM_VAL</name>
	<description>Value of the inductor peak current limit when manually controlled.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_COMP_CLK_VAL</name>
	<description>Value of the output comparator clock when manually controlled.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_FORCE_ILIM</name>
	<description>Enables manual control of the inductor peak current limit.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_FORCE_COMP_TRIM</name>
	<description>Enables manual control of the comparator trim value.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_FORCE_COMP_CLK</name>
	<description>Enables manual control of the output comparator clock.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_SW_TST</name>
	<description>Switch test mode:
0x0: Normal mode (default)
0x1: Force P switch
0x2: Force N switch
0x3: Unused</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_FORCE_TRIG</name>
	<description>Forces a trigger event in the analog FSM.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_FORCE_IDLE</name>
	<description>Forces the DCDC in idle mode, current conversion is finished first.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCDC_TEST2_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>DCDC_COMP_TRIM_VAL</name>
	<description>Value of the comparator trim setting when manually controlled.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DEM</name>
	<version>1.0</version>
	<description>DEM registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40002000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>112</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RF_AFC_CTRL_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000015</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>AFC_SYNCF_DIRECT</name>
	<description>Allow the AFC state to directly transit from IDLE or PREAMBLE detection state to LOCKED state</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>APD_MODE</name>
	<description>Select the mode in the APD FSM:

xx1: Enable the transition from the ADDRESSDETECTION state to the IDLE state when the signal detection is low
x1x: Enable the reset of the AFC filter when the FSM is in the IDLE state
1xx: Enable the time out in the PREAMBLEDETECTION state. The FSM returns to the IDLE state after the time out.</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PAD_MODE</name>
	<description>The PAD mode in BLE mode

00: No limits
01: Wrapping
10: Saturate to zero
11: 580 legacy mode</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AFC_MODE</name>
	<description>Choose the method to use for AFC tracking during the slot
Description TBD </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_AGC_CTRL1_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0056d50d</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>AGC_MODE</name>
	<description>Choose the method to use for AGC evaluation
Description TBD </description>
	<bitRange>[22:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGC_TH2_HIGH</name>
	<description>AGC treshhold for FASTAGC mode... switch up number of steps defined by FASTAGC_STEPS</description>
	<bitRange>[20:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGC_TH_HIGH</name>
	<description>AGC hysteresis high threshold (switch up one AGC_SETTING_R step when exceeding this level) </description>
	<bitRange>[13:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGC_TH_LOW</name>
	<description>AGC hysteresis low threshold (switch down one AGC_SETTING_R step when dropping below this level) </description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_AGC_CTRL2_REG</name>
	
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0040148d</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>EN_FRZ_GAIN</name>
	<description>'0': AGC always active
'1': Freeze gain after Access Address detection </description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGCSETTING_WR</name>
	<description>Fixed AGC setting to be used to configure LNA, VGA1 and VGA2 when AGCSETTING_SEL = 1
0: Highest gain as configured in RF_AGC_LUT_01_REG
1: Lower gain as configured in RF_AGC_LUT_01_REG
2: Still lower gain as configured in RF_AGC_LUT_23_REG
...
9-F: Lowest gain as configured in RF_AGC_LUT_89_REG </description>
	<bitRange>[21:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGCSETTING_SEL</name>
	<description>LNA, VGA1 and VGA2 gains
'0': controlled by AGC
'1': provided manually through AGCSETTING_WR </description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGC_MAX_SETTING</name>
	<description>Maximum AGC setting used from AGC LUT</description>
	<bitRange>[12:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGCDEC_WAIT</name>
	<description>Wait time for settling after a single AGC step decrease (increasing gain)

0x0 - 1us
0x1 - 2us
0x2 - 3us
0x3 - 4us

</description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGCINC_WAIT</name>
	<description>Wait time for settling after a single AGC step increase (decreasing gain)

0x0 - 1us
0x1 - 2us
0x2 - 3us
0x3 - 4us
</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FASTAGC_WAIT</name>
	<description>Wait time for signal settling after fast AGC toggling

0x0 - 1us
0x1 - 2us
0x2 - 3us
0x3 - 4us

</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FASTAGC_STEPS</name>
	<description>Define the number of 6dB steps that is used when the RSSI level
is larger than AGC_TH2_HIGH

0x0 - 1 step
0x1 - 2 steps
0x2 - 3 steps
0x3 - 4 steps

</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FASTAGC_EN</name>
	<description>Allow the AGC to decrease the gain by multiple steps of 6dB

</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_AGC_LUT_0123_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x23030201</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LNA_GAIN3</name>
	<description>LNA gain setting while in AGC setting 3</description>
	<bitRange>[31:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN3</name>
	<description>VGA1 gain setting while in AGC setting 3</description>
	<bitRange>[28:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN3</name>
	<description>VGA2 gain setting while in AGC setting 3</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN2</name>
	<description>LNA gain setting while in AGC setting 2</description>
	<bitRange>[23:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN2</name>
	<description>VGA1 gain setting while in AGC setting 2</description>
	<bitRange>[20:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN2</name>
	<description>VGA2 gain setting while in AGC setting 2</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN1</name>
	<description>LNA gain setting while in AGC setting 1</description>
	<bitRange>[15:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN1</name>
	<description>VGA1 gain setting while in AGC setting 1 </description>
	<bitRange>[12:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN1</name>
	<description>VGA2 gain setting while in AGC setting 1 </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN0</name>
	<description>LNA gain setting while in AGC setting 0 </description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN0</name>
	<description>VGA1 gain setting while in AGC setting 0 </description>
	<bitRange>[4:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN0</name>
	<description>VGA2 gain setting while in AGC setting 0 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_AGC_LUT_4567_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x332f2b27</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LNA_GAIN7</name>
	<description>LNA gain setting while in AGC setting 7</description>
	<bitRange>[31:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN7</name>
	<description>VGA1 gain setting while in AGC setting 7</description>
	<bitRange>[28:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN7</name>
	<description>VGA2 gain setting while in AGC setting 7</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN6</name>
	<description>LNA gain setting while in AGC setting 6</description>
	<bitRange>[23:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN6</name>
	<description>VGA1 gain setting while in AGC setting 6</description>
	<bitRange>[20:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN6</name>
	<description>VGA2 gain setting while in AGC setting 6</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN5</name>
	<description>LNA gain setting while in AGC setting 5</description>
	<bitRange>[15:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN5</name>
	<description>VGA1 gain setting while in AGC setting 5</description>
	<bitRange>[12:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN5</name>
	<description>VGA2 gain setting while in AGC setting 5</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN4</name>
	<description>LNA gain setting while in AGC setting 4</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN4</name>
	<description>VGA1 gain setting while in AGC setting 4</description>
	<bitRange>[4:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN4</name>
	<description>VGA2 gain setting while in AGC setting 4</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_AGC_LUT_89AB_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x77775737</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LNA_GAIN11</name>
	<description>LNA gain setting while in AGC setting 11</description>
	<bitRange>[31:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN11</name>
	<description>VGA1 gain setting while in AGC setting 11</description>
	<bitRange>[28:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN11</name>
	<description>VGA2 gain setting while in AGC setting 11</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN10</name>
	<description>LNA gain setting while in AGC setting 10</description>
	<bitRange>[23:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN10</name>
	<description>VGA1 Gain setting while in AGC setting 10</description>
	<bitRange>[20:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN10</name>
	<description>VGA2 gain setting while in AGC setting 10</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN9</name>
	<description>LNA gain setting while in AGC setting 9 </description>
	<bitRange>[15:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN9</name>
	<description>VGA1 gain setting while in AGC setting 9 </description>
	<bitRange>[12:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN9</name>
	<description>VGA2 gain setting while in AGC setting 9 </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN8</name>
	<description>LNA gain setting while in AGC setting 8 </description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN8</name>
	<description>VGA1 gain setting while in AGC setting 8 </description>
	<bitRange>[4:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN8</name>
	<description>VGA2 gain setting while in AGC setting 8 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_AGC_LUT_CDEF_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x01022243</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LNA_GAIN15</name>
	<description>LNA gain setting while in AGC setting 15</description>
	<bitRange>[31:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN15</name>
	<description>VGA1 gain setting while in AGC setting 15</description>
	<bitRange>[28:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN15</name>
	<description>VGA2 gain setting while in AGC setting 15</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN14</name>
	<description>LNA gain setting while in AGC setting 14</description>
	<bitRange>[23:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN14</name>
	<description>VGA1 Gain setting while in AGC setting 14</description>
	<bitRange>[20:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN14</name>
	<description>VGA2 gain setting while in AGC setting 14</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN13</name>
	<description>LNA gain setting while in AGC setting 13</description>
	<bitRange>[15:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN13</name>
	<description>VGA1 gain setting while in AGC setting 13</description>
	<bitRange>[12:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN13</name>
	<description>VGA2 gain setting while in AGC setting 13</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_GAIN12</name>
	<description>LNA gain setting while in AGC setting 12</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA1_GAIN12</name>
	<description>VGA1 gain setting while in AGC setting 12</description>
	<bitRange>[4:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VGA2_GAIN12</name>
	<description>VGA2 gain setting while in AGC setting 12</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_AGC_RESULT_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>AGCSETTING_RD</name>
	<description>AGC setting as automatically selected in receive mode to configure LNA, VGA1 and VGA2
0: Highest gain as configured in RF_AGC_LUT_01_REG
1: Lower gain as configured in RF_AGC_LUT_01_REG
2: Still lower gain as configured in RF_AGC_LUT_23_REG
...
9-F: Lowest gain as configured in RF_AGC_LUT_89_REG </description>
	<bitRange>[11:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AFC_RD</name>
	<description>Frequency offset estimation (in 2s complement) with a resolution of approximately 5 kHz. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_CTRL1_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00020100</resetValue>
	<resetMask>0x0003fdfe</resetMask>
	<fields><field>
	<name>DCOFFSET_Q_WR</name>
	<description>DC offset compensation value in Q channel valid when DCOFFSET_SEL = 1
In Barium only 8 Bit DAC is used. LSB of 9-bit DAC from D2522 is no longer needed.</description>
	<bitRange>[17:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOFFSET_I_WR</name>
	<description>DC offset compensation value in I channel valid when DCOFFSET_SEL = 1
n Barium only 8 Bit DAC is used. LSB of 9-bit DAC from D2522 is no longer needed.</description>
	<bitRange>[8:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_CTRL2_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00f86696</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>DCOC_RESULT_LNAGAIN345_LUT</name>
	<description>DCoffset result used for LNA gain settings 3 4 and 5. </description>
	<bitRange>[23:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOC_RESULT_LNAGAIN2_LUT</name>
	<description>DCoffset result used for LNA gain setting 2</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOC_RESULT_LNAGAIN1_LUT</name>
	<description>DCoffset result used for LNA gain setting 1</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOC_RESULT_LNAGAIN0_LUT</name>
	<description>DCoffset result used for LNA gain setting 0</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCPAR_DCF_EN</name>
	<description>Use a DCF to start the partial DC offset calibration.
</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCPAR_MULT_STEPS_EN</name>
	<description>Enable the partial DCOC calibration with multiple gain settings.
When not set, the partial calibration is the same as in 680BA.

</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCPARNGAIN</name>
	<description>Number of gain settings for the partial DC offset calibration</description>
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCVGA1SCALE_EN</name>
	<description>Enable the DC offset scaling with the VGA1 gain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCPARCAL_INIT</name>
	<description>Select the inital value used for the partial DC offset calibration.

0: The DC offset from the previous packet
1: The DC offset found with the full DC offset calibration
2: Start from the mid value. </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCFULLNGAIN</name>
	<description>Number of gain settings for the full DC offset calibration </description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCNSTEP</name>
	<description>Number of the steps per.gain setting for the full or partial DC offset calibrations </description>
	<bitRange>[4:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCPARCAL_EN</name>
	<description>Enable flag for the partial DC offset calibration The calbration is executed when the demodulator is enabled. 
When the bit DCPAR_DCF_EN is set, the enabling is started by the DCF. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOFFSET_SEL</name>
	<description>'0': Normal operation
'1': Use the manual DC offset compensation values from RF_DC_OFFSET_CTRL1_REG </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_CTRL3_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000dce4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DCBETA_Q</name>
	<description>Quadrature feedback gain for the DC offset calibration

Value for DCBETA depends on the IFF DCOC REF CURR
setting, ratio_580_refcurr, preferred_settingRF_DC_OFFSET_CTRL3_REG
0, 1x, 0xDCE4
1, 2x, 0xEEF2
2, 3x, 0xF4F7
3, 4x, 0xF7F9






</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCBETA_I</name>
	<description>Inphase feedback gain for the DC offset calibration

Value for DCBETA depends on the IFF DCOC REF CURR
setting, ratio_580_refcurr, preferred_settingRF_DC_OFFSET_CTRL3_REG
0, 1x, 0xDCE4
1, 2x, 0xEEF2
2, 3x, 0xF4F7
3, 4x, 0xF7F9</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_CTRL4_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00009210</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DCAGCSETTING_FULL3</name>
	<description>AGC setting for forth last the gain step for the full DC offset calibration </description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCAGCSETTING_FULL2</name>
	<description>AGC setting for third last the gain step for the full DC offset calibration </description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCAGCSETTING_FULL1</name>
	<description>AGC setting for second last the gain step for the full DC offset calibration </description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCAGCSETTING_FULL0</name>
	<description>AGC setting for last the gain step for the full DC offset calibration </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_FULL_RES_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>DCOFFSET_Q_RD</name>
	<description>Stored DC offset FULL calibration result value of the Q channel. </description>
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOFFSET_I_RD</name>
	<description>Stored DC offset FULL calibration result value of the Q channel. </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_MPAR_RES0_REG</name>
	
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>DCOFFSET_Q_RD</name>
	<description>DC offset calibration result value of the last step of the multiple partial calibration. (Q channel) </description>
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOFFSET_I_RD</name>
	<description>DC offset calibration result value of the last step of the multiple partial calibration. (I channel) </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_MPAR_RES1_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>DCOFFSET_Q_RD</name>
	<description>DC offset calibration result value of the (last step -1) of the multiple partial calibration. (Q channel) </description>
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOFFSET_I_RD</name>
	<description>DC offset calibration result value of the (last step -1) of the multiple partial calibration. (I channel) </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_MPAR_RES2_REG</name>
	
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>DCOFFSET_Q_RD</name>
	<description>DC offset calibration result value of the (last step -2) of the multiple partial calibration. (Q channel) </description>
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOFFSET_I_RD</name>
	<description>DC offset calibration result value of the (last step-2) of the multiple partial calibration. (I channel) </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_MPAR_RES3_REG</name>
	
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>DCOFFSET_Q_RD</name>
	<description>DC offset calibration result value of the (last step -3) of the multiple partial calibration. (Q channel) </description>
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOFFSET_I_RD</name>
	<description>DC offset calibration result value of the (last step-3) of the multiple partial calibration. (I channel) </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_DC_OFFSET_RESULT_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>DCOFFSET_Q_RD</name>
	<description>DC offset compensation value in Q channel valid when DCOFFSET_SEL = 0</description>
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOFFSET_I_RD</name>
	<description>DC offset compensation value in I channel valid when DCOFFSET_SEL = 0. </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_DEM_ATTR_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00c4a18f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ADDR_TIMEOUT_X2</name>
	<description>Program the Address Time Out when AFC is in MAC ADDRESS correlation state

0x0 - short time (32us in 2Mbit mode and 64us in 1Mbit mode)
0x1 - long time (64us in 2Mbit mode and 128us in 1Mbit mode)

</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFADC_CLK_PHASE</name>
	<description>Select the phase of the RFADC clock</description>
	<bitRange>[23:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RSSI_TH</name>
	<description>RSSI threshold for the packet detection </description>
	<bitRange>[20:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCPOLE</name>
	<description>Set the frequency of the DC offset highpass filter.

The frequency is different when the demodulator is used with 8MHz or 16MHz clock. 

For 8MHz clock:

0x0 - 100kHz
0x1 - 50kHz
0x2 - 150kHz
0x3 - N/A </description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOC_SPEED8M_EN</name>
	<description>Set the preferred Clock Speed for the DC Offset Block </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGC_SPEED8M_EN</name>
	<description>Set the preferred clock speed for the AGC block</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MATCH0101_TH</name>
	<description>Threshold for the 0101 pattern matching </description>
	<bitRange>[9:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_HSI_POL</name>
	<description>Invert &quot;frequency&quot; polarity of the demodulator </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXDATA_INV</name>
	<description>'0': Normal operation
'1': Invert the polarity of the received bits</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AFC_POLE2</name>
	<description>
Set the frequency of the AFC pole (Highpass filter) that is used before and after preamble detection.
The absolute frequency is different for 1Mbit and 2Mbit mode.

3dB cut off frequency in 1Mbit mode.

0 - NA
1 - 78Hz
2 - 156Hz
3 - 311Hz

In 2Mbit mode, the frequency doubles.

</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AFC_POLE1</name>
	<description>
Set the frequency of the AFC pole (Highpass filter) that is used during preamble detection.
The absolute frequency is different for 1Mbit and 2Mbit mode.

3dB cut off frequency in 1Mbit mode.

0 - NA
1 - 1.3kHz
2 - 2.5kHz
3 - 5.1kHz

In 2Mbit mode, the frequency doubles.


</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_DEM_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>IQ_TO_GPIO_EN</name>
	<description>Enable the IQ data output for exposed radio mode. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AGC_USE_GPIO_IN</name>
	<description>Select to use the GPIO input as AGC setting.
To be used with FPGA platform
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IQCORR_EN</name>
	<description>Enable the IQ mismatch correction

The correction coefficients are define in the RF_DEM_IQCORRECT_REG register</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_DDC_EN</name>
	<description>Enable the digital conversion in BLE mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EQUAL_EN</name>
	<description>Enable the equalizer in the demodulator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_DEM_IQCORRECT_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IQCORR_ALPHA</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IQCORR_BETA</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_DEM_TESTMODE_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>DEM_RFMON_TRIGGER</name>
	<description>Selects the trigger of the acquisition:

0: DEM_EN
1: Signal detected
2: Set with the rising edge of DEM_EN and reset with the rising edge of SYNC_FOUND_P
3: Set with the rising edge of SYNC_FOUND_P and reset with the falling edge of DEM_EN

Note:
Triggering is guaranteed for the DEM-only test modes. For GPADC and ADPLL and mixes of the 3 (DEM-GPADC-ADPLL) it is TBD.

Note:
Please check bug2522A_018 (DEM 16Msps data need 16MHz RFCU clock).
Also check bug2522A_019 (ADPLL RFMON metastability issue. Need to run with xtal32M to be safe, and use correct setting for polarity inversion bit)</description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_GPADC_MUX_SEL</name>
	<description>Selects the combination of DEM test data and GPADC test data, according to the mapping below:

0: {0000000000000000, gpadc_data[15:0]}
1: {0000000000000000, gpadc_data[15:0]}
2: {0000000000000000, dem_data[15:0]}
3: {0000000000000000, dem_data[31:16]}
4: {dem_data[31:16], gpadc_data[15:0]}
5: {dem_data[15:0], gpadc_data[15:0]}
6: dem_data
7: {dem_data[15:0], dem_data[31:16]}

Note:
You need to enable the GPADC in order to see GPADC test data.

Note:
Please check bug2522A_018 (DEM 16Msps data need 16MHz RFCU clock).
Also check bug2522A_019 (ADPLL RFMON metastability issue. Need to run with xtal32M to be safe, and use correct setting for polarity inversion bit)</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_RFMON_SOURCE</name>
	<description>Selects the data mapped on the testbus (see demodulator documentation for details).

0: disabled (default)
1: testbus_data := adcout_i(8 downto 1) &amp; adcout_q(8 downto 1)&amp; '0' &amp; ble_rxdata &amp; hpf_output &amp; pad_output;testbus_dem_en &lt;= testbus_trig;
2:testbus_data := dnmin &amp; dpmin &amp; '0' &amp; ble_rxdata &amp; hpf_output &amp; pad_output;testbus_dem_en &lt;= testbus_trig;
3:testbus_data := adcout_i &amp; adcout_q &amp; agc_setting &amp; vga3_out_i &amp; vga3_out_q;testbus_dem_en &lt;= testbus_trig;
4:testbus_data := &quot;00000000000&quot; &amp; rssi_raw &amp; agc_setting &amp; envelope;testbus_dem_en &lt;= testbus_trig;
5:testbus_data := &quot;0000&quot; &amp; demin_q_acc &amp; &quot;0000&quot; &amp; demin_i_acc;testbus_dem_en &lt;= dcoffsetcal_en;
6:testbus_data := &quot;00&quot; &amp; ble_rxdata &amp; agc_setting &amp; adcout_i &amp; envelope &amp; adcout_q ;testbus_dem_en &lt;= testbus_trig;
7:testbus_data := adcout_i(8 downto 1) &amp; adcout_q(8 downto 1) &amp; apd_state &amp; hpf_output &amp; pad_output; testbus_dem_en &lt;= testbus_trig;
8:testbus_data := adcout_i_prev(8 downto 1) &amp; adcout_qprev(8 downto 1) &amp; adcout_i_now(8 downto 1)
&amp; adcout_q_now(8 downto 1) ; testbus_dem_en &lt;= test_bus_trig @ 4MHz
9 ..., 15: reserved

Note:
Please check bug2522A_018 (DEM 16Msps data need 16MHz RFCU clock).
Also check bug2522A_019 (ADPLL RFMON metastability issue. Need to run with xtal32M to be safe, and use correct setting for polarity inversion bit)</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_PAD_CNT_CTRL_REG</name>
	
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00004000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>PAD_CLEAR_COUNT</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PAD_NEG_LIMIT</name>
	
	<bitRange>[13:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PAD_POS_LIMIT</name>
	
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_PAD_CNT_RESULT_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PAD_NEG_CNT_RD</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PAD_POS_CNT_RD</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_RSSI_COMP_CTRL_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00088888</resetValue>
	<resetMask>0x000fffff</resetMask>
	<fields><field>
	<name>RSSI_COMP4</name>
	<description>RSSI compensation value for LNA gain setting 3
Coding identical to RSSI_COMP0</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RSSI_COMP3</name>
	<description>RSSI compensation value for LNA gain setting 3
Coding identical to RSSI_COMP0</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RSSI_COMP2</name>
	<description>RSSI compensation value for LNA gain setting 2
Coding identical to RSSI_COMP0</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RSSI_COMP1</name>
	<description>RSSI compensation value for LNA gain setting 1
'0x0': -8
'0x1': -7
'0x2': -6
'0x3': -5
'0x4': -4
'0x5': -3
'0x6': -2
'0x7': -1
'0x8': 0 (reset)
'0x9': 1
'0xA': 2
'0xB': 3
'0xC': 4
'0xD': 5
'0xE': 6
'0xF': 7 </description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RSSI_COMP0</name>
	<description>RSSI compensation value for LNA gain setting 00
'0x0': -8
'0x1': -7
'0x2': -6
'0x3': -5
'0x4': -4
'0x5': -3
'0x6': -2
'0x7': -1
'0x8': 0 (reset)
'0x9': 1
'0xA': 2
'0xB': 3
'0xC': 4
'0xD': 5
'0xE': 6
'0xF': 7 </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_RSSI_RESULT_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000fffff</resetMask>
	<fields><field>
	<name>RSSI_AVG_RD</name>
	<description>RSSI value measured in averaging mode in continuous RX mode (used for LNA selectivity calibration) </description>
	<bitRange>[19:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RSSI_LATCHED_RD</name>
	<description>Averaged RSSI value latched with the Sync Found Pulse.
Value is resetted when the demodulator is started and when stopped.
</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DMA</name>
	<version>1.0</version>
	<description>DMA registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>134</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DMA0_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 0</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 0</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_CTRL_REG</name>
	<description>Control register for the DMA channel 0</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_IDX_REG</name>
	<description>Index value of DMA channel 0</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA0_INT_REG</name>
	<description>DMA receive interrupt register channel 0</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_LEN_REG</name>
	<description>DMA receive length register channel 0</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 1</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 1</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 1</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 1</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_CTRL_REG</name>
	<description>Control register for the DMA channel 1</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_IDX_REG</name>
	<description>Index value of DMA channel 1</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA1_INT_REG</name>
	<description>DMA receive interrupt register channel 1</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_LEN_REG</name>
	<description>DMA receive length register channel 1</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 2</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 2</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 2</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_CTRL_REG</name>
	<description>Control register for the DMA channel 2</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address
0 = do not increment
1 = increment according value of BW</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_IDX_REG</name>
	<description>Index value of DMA channel 2</description>
	<addressOffset>0x0000002e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA2_INT_REG</name>
	<description>DMA receive interrupt register channel 2</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_LEN_REG</name>
	<description>DMA receive length register channel 2</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 3</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 3</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 3</description>
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 3</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_CTRL_REG</name>
	<description>Control register for the DMA channel 3</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_IDX_REG</name>
	<description>Index value of DMA channel 3</description>
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA3_INT_REG</name>
	<description>DMA receive interrupt register channel 3</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_LEN_REG</name>
	<description>DMA receive length register channel 3</description>
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA_CLEAR_INT_REG</name>
	<description>DMA clear interrupt register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA_RST_IRQ_CH3</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 3 ; writing a 0 will have no effect</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH2</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 2 ; writing a 0 will have no effect</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH1</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 1 ; writing a 0 will have no effect</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH0</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 0 ; writing a 0 will have no effect</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>DMA_INT_STATUS_REG</name>
	<description>DMA interrupt status register</description>
	<addressOffset>0x00000082</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA_IRQ_CH3</name>
	<description>0: IRQ on channel 3 is not set
1: IRQ on channel 3 is set</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH2</name>
	<description>0: IRQ on channel 2 is not set
1: IRQ on channel 2 is set</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH1</name>
	<description>0: IRQ on channel 1 is not set
1: IRQ on channel 1 is set</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH0</name>
	<description>0: IRQ on channel 0 is not set
1: IRQ on channel 0 is set</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA_REQ_MUX_REG</name>
	<description>DMA channel assignments</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA23_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Hence, the first DMA request (peripheral-to-memory) is mapped on channel 2 and the second (memory-to-peripheral) on channel 3.
See also the description of DMA01_SEL bit-field of this register for the supported peripherals.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA01_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Hence, the first DMA request (peripheral-to-memory) is mapped on channel 0 and the second (memory-to-peripheral) on channel 1.
0x0: SPI_rx / SPI_tx
0x1: Reserved
0x2: UART_rx / UART_tx
0x3: UART2_rx / UART2_tx
0x4: I2C_rx / I2C_tx
0x5: GP_ADC (Rx only)
0x6-0xE: Reserved
0xF: None

Note: If any of the two available peripheral selector fields (DMA01_SEL, DMA23_SEL) have the same value, the lesser significant selector has higher priority and will control the dma acknowledge. Hence, if DMA01_SEL = DMA23_SEL, the channels 0 and 1 will generate the DMA acknowledge signals for the selected peripheral. Consequently, it is suggested to assign the intended peripheral value to a unique selector field.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPADC</name>
	<version>1.0</version>
	<description>GPADC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>32</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GP_ADC_CLEAR_INT_REG</name>
	<description>General Purpose ADC Clear Interrupt Register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_CLR_INT</name>
	<description>Writing any value to this register will clear the ADC_INT interrupt. Reading returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL2_REG</name>
	<description>General Purpose ADC Second Control Register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000210</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_STORE_DEL</name>
	<description>0: Data is stored after handshake synchronisation
1: Data is stored 2 ADC_CLK cycles after internal start trigger
7: Data is stored 8 ADC_CLK cycles after internal start trigger</description>
	<bitRange>[15:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SMPL_TIME</name>
	<description>0: The sample time (switch is closed) is two ADC_CLK cycles
1: The sample time is 1*8 ADC_CLK cycles
2: The sample time is 2*8 ADC_CLK cycles
15: The sample time is 15*8 ADC_CLK cycles</description>
	<bitRange>[12:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONV_NRS</name>
	<description>0: 1 sample is taken or 2 in case ADC_CHOP is active.
1: 2 samples are taken.
2: 4 samples are taken.
7: 128 samples are taken.</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_OFFS_SH_CM</name>
	<description>Common mode adjust for offset shifter. Input range is CM +/- 450mV.
0: CM = 1.25V (Input range 0.80 - 1.70)
1: CM = 1.30V (Input range 0.85 - 1.75) (default)
2: CM = 1.35V (Input range 0.90 - 1.80)
3: CM = 1.40V (input range 0.95 - 1.85)</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_OFFS_SH_EN</name>
	<description>0: Disable input shifter
1: Enable input shifter (900mV - 1800mV shifted to 0mV - 900mV)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_I20U</name>
	<description>1: Adds 20uA constant load current at the ADC LDO to minimize ripple on the reference voltage of the ADC.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_ATTN</name>
	<description>0: No attenuator (input voltages up to 0.9V allowed)
1: Enabling 2x attenuator (input voltages up to 1.8V allowed)
2: Enabling 3x attenuator (input voltages up to 2.7V allowed)
3: Enabling 4x attenuator (input voltages up to 3.6V allowed)
Enabling the attenuator requires a longer sampling time.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL3_REG</name>
	<description>General Purpose ADC Third Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_INTERVAL</name>
	<description>Defines the interval between two ADC conversions in case GP_ADC_CONT is set.
0: No extra delay between two conversions.
1: 1.024 ms interval between two conversions.
2: 2.048 ms interval between two conversions.
255: 261.12 ms interval between two conversions.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN_DEL</name>
	<description>Defines the delay for enabling the ADC after enabling the LDO.
0: Not allowed
1: 4x ADC_CLK period.
n: n*4x ADC_CLK period.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL_REG</name>
	<description>General Purpose ADC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>DIE_TEMP_EN</name>
	<description>Enables the die-temperature sensor. Output can be measured on GPADC input 4.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_OFFS_SH_GAIN_SEL</name>
	<description>Gain of the input shifter
0: 2x (default)
1: 2.25x</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_LDO_HOLD</name>
	<description>0: GPADC LDO tracking bandgap reference
1: GPADC LDO hold sampled bandgap reference</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CHOP</name>
	<description>0: Chopper mode off
1: Chopper mode enabled. Takes two samples with opposite GP_ADC_SIGN to cancel the internal offset voltage of the ADC; Highly recommended for DC-measurements.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SIGN</name>
	<description>0: Default
1: Conversion with opposite sign at input and output to cancel out the internal offset of the ADC and low-frequency</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MUTE</name>
	<description>0: Normal operation
1: Mute ADC input. Takes sample at mid-scale (to dertermine the internal offset and/or noise of the ADC with regards to VDD_REF which is also sampled by the ADC).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SE</name>
	<description>0: Differential mode
1: Single ended mode</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MINT</name>
	<description>0: Disable (mask) GP_ADC_INT.
1: Enable GP_ADC_INT to ICU.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_INT</name>
	<description>1: AD conversion ready and has generated an interrupt. Must be cleared by writing any value to GP_ADC_CLEAR_INT_REG.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GP_ADC_DMA_EN</name>
	<description>0: DMA functionality disabled
1: DMA functionality enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONT</name>
	<description>0: Manual ADC mode, a single result will be generated after setting the GP_ADC_START bit.
1: Continuous ADC mode, new ADC results will be constantly stored in GP_ADC_RESULT_REG. Still GP_ADC_START has to be set to start the execution. The time between conversions is configurable with GP_ADC_INTERVAL.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_START</name>
	<description>0: ADC conversion ready.
1: If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the GP_ADC_INT bit will be set. It is not allowed to write this bit while it is not (yet) zero.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN</name>
	<description>0: LDO is off and ADC is disabled..
1: LDO is turned on and afterwards the ADC is enabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFN_REG</name>
	<description>General Purpose ADC Negative Offset Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFN</name>
	<description>Offset adjust of 'negative' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=1 OR GP_ADC_CHOP=1&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFP_REG</name>
	<description>General Purpose ADC Positive Offset Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFP</name>
	<description>Offset adjust of 'positive' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=0 OR GP_ADC_CHOP=1&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_PARAM_DIF_REG</name>
	<description>General Purpose ADC Parameter Differential Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000000</resetMask>
	
</register><register>
	<name>GP_ADC_PARAM_SE_REG</name>
	<description>General Purpose ADC Parameter Single Ended Register</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000000</resetMask>
	
</register><register>
	<name>GP_ADC_RESULT_REG</name>
	<description>General Purpose ADC Result Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_VAL</name>
	<description>Returns the 10 up to 16 bits linear value of the last AD conversion. The upper 10 bits are always valid, the lower 6 bits are only valid in case oversampling has been applied. Two samples results in one extra bit and 64 samples results in six extra bits.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_TRIM_REG</name>
	<description>General Purpose ADC Trim Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000038</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>GP_ADC_LDO_LEVEL</name>
	<description>GPADC LDO level
0: 825mV
1: 850mV
2: 875mV
3: 900mV (default)
4: 925mV
5: 950mV
6: 975mV
7:1000mV</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_OFFS_SH_VREF</name>
	<description>Offset Shifter common-mode reference fine trimming: 2mV/LSB
Default = mid-scale at 1000</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPIO</name>
	<version>1.0</version>
	<description>GPIO registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>66</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BIST_CTRL_REG</name>
	<description>BIST Control Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000480</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SYSRAM3_BIST_ENABLE</name>
	<description>Enables the SYSRAM3 BIST</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM_BIST_PATTERN</name>
	<description>Determines the pattern to be used for the SYSRAM BIST tests, as follows:
00 = Use 0x5555 as test data
01 = Use 0x5A5A as test data
10 = Use 0x0000 as test data
11 = Use 0x0F0F as test data </description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYSRAM12_BIST_BUSY</name>
	<description>Reads the BIST BUSY status bit for SYSRAM12</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYSRAM12_BIST_FAIL</name>
	<description>Reads the BIST FAIL status bit for SYSRAM12</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYSRAM3_BIST_BUSY</name>
	<description>Reads the BIST BUSY status bit for SYSRAM3</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYSRAM3_BIST_FAIL</name>
	<description>Reads the BIST FAIL status bit for SYSRAM3</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ROM_BIST_BUSY</name>
	<description>Reads the BIST BUSY status bit for ROM </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYSRAM12_BIST_ENABLE</name>
	<description>Enables the SYSRAM12 BIST </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ROMBIST_ENABLE</name>
	<description>Enables the ROM BIST</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM_BIST_CONFIG</name>
	<description>SYSRAM and ROM BIST configuration:
00 = Perform all 8 phases
01 = Perform only phase 1
10 = Perform only phase 3 and 4
11 = Perform only phase 6 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P00_MODE_REG</name>
	<description>P00 Mode Register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0  =  GPIO (pin direction determined by &quot;PUPD&quot; field)
1  =  UART1_RX
2  =  UART1_TX
3  =  UART2_RX
4  =  UART2_TX
5  =  SYS_CLK
6  =  LP_CLK
7  =  Reserved
8  =  Reserved
9  =  I2C_SCL
10 = I2C_SDA
11 = PWM5
12 = PWM6
13 = PWM7
14 = Reserved
15 = ADC (only for P0_1, P0_2, P0_6 and P0_7)
16 = PWM0
17 = PWM1
18 = BLE_DIAG (signals mapped to P0[3:0] are also mapped to P0[11:8])
19 = UART1_CTSN
20 = UART1_RTSN
21 = Reserved
22 = Reserved
23 = PWM2
24 = PWM3
25 = PWM4
26 = SPI_DI
27 = SPI_DO
28 = SPI_CLK
29 = SPI_CSN0
30 = SPI_CSN1
31 = Reserved
Note: When a certain input function (like SPI_DI) is selected on more than 1 pins, the pin of the lowest index has the highest priority.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P010_MODE_REG</name>
	<description>P010 Mode Register</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P011_MODE_REG</name>
	<description>P011 Mode Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P01_MODE_REG</name>
	<description>P01 Mode Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P02_MODE_REG</name>
	<description>P02 Mode Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P03_MODE_REG</name>
	<description>P03 Mode Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P04_MODE_REG</name>
	<description>P04 Mode Register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P05_MODE_REG</name>
	<description>P05 Mode Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P06_MODE_REG</name>
	<description>P06 Mode Register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P07_MODE_REG</name>
	<description>P07 Mode Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P08_MODE_REG</name>
	<description>P08 Mode Register</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P09_MODE_REG</name>
	<description>P09 Mode Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_DATA_REG</name>
	<description>P0 Data input/output Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_DATA</name>
	<description>Sets P0 output register when written ; Returns the value of P0 port when read </description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_RESET_DATA_REG</name>
	<description>P0 Reset port pins Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_RESET</name>
	<description>Writing a 1 to P0[x] sets P0[x] to 0.
Writing 0 is discarded, reading returns 0.</description>
	<bitRange>[11:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P0_SET_DATA_REG</name>
	<description>P0 Set port pins Register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_SET</name>
	<description>Writing a 1 to P0[x] sets P0[x] to 1.
Writing 0 is discarded, reading returns 0 </description>
	<bitRange>[11:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>PAD_WEAK_CTRL_REG</name>
	<description>Pad driving strength control Register</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PAD_LOW_DRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_x pad.
Bit x controls the driving strength of P0_x, x=0, 1,..., 11.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ROMBIST_RESULTH_REG</name>
	<description>ROMBIST MSB Result Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ROMBIST_RESULTH</name>
	<description>Reads the 16 MSBs of the ROM BIST status result (bits [31:16]).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ROMBIST_RESULTL_REG</name>
	<description>ROMBIST LSB Result Register</description>
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ROMBIST_RESULTL</name>
	<description>Reads the 16 LSBs of the ROM BIST status result (bits [15:0]).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SCAN_OBSERVE_REG</name>
	<description>Scan observe Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SCAN_FEEDBACK_MUX</name>
	<description>This register provides feedback on the status of the ports' output and control signals, in scan test mode. The multiplexer's output is controlled by P0_DATA_REG[3:0].</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TEST_CTRL2_REG</name>
	<description>Test Control Register 2</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ANA_TEST_OUT_PARAM</name>
	<description>Select block parameter to connect to analog testbus (not always mutually exlusive)

Bandgap (ANA_TEST_OUT_SEL=0x002), 1-hot decoder (4 bits)
0x0: vref_0v75_0
0x1: vref_0v75_1
0x2: vref_radio_0v75
0x3: vref_radio_0v725
0x4: ibp_5uA_test
0x5: ext_5uA_to_100k
0x6: int_5uA_to_100k
0x7: vref0v75
0x8: vref0v725
0x9: vssa_bg
0xA: vdda_filt_3v0

WUP (ANA_TEST_OUT_SEL=0x004), no decoder
0x1: ibn_gen_test_10n
0x2: vdda_wup
0x4: vdda_vcont_3v
0x8: vcont_wup

DCDC (ANA_TEST_OUT_SEL=0x008), no decoder
0x1: scaler_out
0x2: scaler_ref
0x4: psw_i_ref
0x8: nsw_i_ref

LDO_CORE (ANA_TEST_OUT_SEL=0x010), no decoder
0x1: ota_out

LDO_LOW (ANA_TEST_OUT_SEL=0x020), direct selection
0xX: vref1v1

CP (ANA_TEST_OUT_SEL=0x040), 1-hot decoder (1 bit)
0x0: vcharge_out
0x1: vcp (make sure VBAT_HIGH &gt;2x VBAT_LOW)

Die Temp (ANA_TEST_OUT_SEL=0x080), direct selection
0xX: vptat

XTAL32MHz (ANA_TEST_OUT_SEL=0x100), direct selection
0xX: ldo_xtal_vout
note: more xtal testmodes in xtal ctrl registers

GPADC (ANA_TEST_OUT_SEL=0x200), direct selection
0xX: ldo_gpadc_vout</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ANA_TEST_OUT_TO_PIN</name>
	<description>0: Testbus internal use (GPADC)
1: Testbus connected to P0_3. The direction of P0_3 pad automatically switches to Input with PU/PD resistors disabled and input enable (ie) also disabled, when this bit-field is set to '1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ANA_TEST_OUT_SEL</name>
	<description>Select block to connect to analog testbus (not mutually exlusive)
0x000: High-Z
0x001: Testbus to ground
0x002: Bandgap
0x004: WUP
0x008: DCDC
0x010: LDO_CORE
0x020: LDO_LOW
0x040: CP
0x080: Die Temp
0x100: XTAL32MHz
0x200: GPADC</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TEST_CTRL3_REG</name>
	<description>Test Control Register 3</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RF_TEST_OUT_TO_PIN</name>
	<description>0: Radio output testbus internal use
1: Radio output testbus connected to P0_1 and P0_3. The direction of P0_1 and P0_3 pads automatically switches to Input with PU/PD resistors disabled and input enable (ie) also disabled, when this bit-field is set to '1'.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_TEST_OUT_PARAM</name>
	<description>Select which test will be enabled on the block selected by the RF output testbus
RF_TEST_OUT_SEL = 2 radio ldo tests
RF_TEST_OUT_PARAM&lt;3:0&gt; test_out_a&lt;1&gt; test_out_a&lt;0&gt;
xx00                                      High-Z            High-Z
xx01                                      High-Z            ldo_radio_pssrr_cap
xx10                                      ldo_radio out  High-Z
xx11                                      ldo_radio out  ldo_radio_pssrr_cap

RF_TEST_OUT_SEL = 4 IFF output tests
RF_TEST_OUT_PARAM&lt;3:0&gt; test_out_a&lt;1&gt; test_out_a&lt;0&gt;
x000 vga2_out_in_a vga2_out_ip_a
x001 vga2_out_qn_a vga2_out_qp_a
x010 vga1_out_in_a vga1_out_ip_a
x011 vga1_out_qn_a vga1_out_qp_a
x100 vga1_out_qn_a vga1_out_ip_a
x101 vga2_out_qn_a vga2_out_ip_a
x110 High-Z amp_vcmref_a
x111 tes_in_a&lt;0&gt; High-Z

RF_TEST_OUT_SEL = 8 TIA output tests
RF_TEST_OUT_PARAM&lt;3:0&gt; test_out_a&lt;1&gt; test_out_a&lt;0&gt;
xx00 mixout_ip_a mixout_in_a
xx01 mixout_qp_a mixout_qn_a
xx1x High-Z vcm_tia

RF_TEST_OUT_SEL = 16 ADPLL/ldo test
RF_TEST_OUT_PARAM&lt;3:0&gt; test_out_a&lt;1&gt; test_out_a&lt;0&gt;
000x High-Z
001x pwrp_dco_a
010x pwrp_tdc_a
011x High-Z
100x High-Z
101x tb_out_dco_a
110x vref1_a
111x tst_tdc_out_c
0011 pwrn_dco_a
0101 pwrn_tdc_a

Note: above table might need to be cross-checked and updated.</description>
	<bitRange>[12:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENABLE_RFPT</name>
	<description>0: normal port function
1: enables the RF Production Test Unit. Used to store RX ADC samples or PLL TDC samples in SRAM.
See RFPT_CTRL_REG, RFPT_ADDR_REG and RFPT_LEN_REG for details.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_TEST_OUT_SEL</name>
	<description>Select a radio block to have its testbus connected to P0[1] and P0[3]. See RF_TEST_OUT_PARAM for more information.
NOTE: all 0 represent no testmode and the testbusses are floating in this mode except in reset state the testbuses are pulled to ground.
RF_TEST_OUT_SEL=000001: short test_out_a&lt;1:0&gt; to ground
RF_TEST_OUT_SEL=000010: test radio ldo
RF_TEST_OUT_SEL=000100: test IFF
RF_TEST_OUT_SEL=001000: test MIX
RF_TEST_OUT_SEL=010000: test ADPLL
</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TEST_CTRL4_REG</name>
	<description>Test Control Register 4</description>
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RF_TEST_IN_TO_PIN</name>
	<description>0: Radio input testbus internal use
1: Radio input testbus connected to P0_2 and P0_4. The direction of P0_2 and P0_4 pads automatically switches to Input with PU/PD resistors disabled and input enable (ie) also disabled, when this bit-field is set to '1'.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_TEST_IN_PARAM</name>
	<description>Selects which test will be enabled on the block selected by the RF input testbus.
RF_TEST_IN_SEL = 2
RF_TEST_IN_PARAM&lt;3:0&gt;   test_in_a&lt;1&gt;   test_in_a&lt;0&gt;    Condition
xxx0                                     adcinp_i_a     adcinn_i_a        adc_mute=0
xxx1                                     adcinp_q_a    adcinn_q_a      adc_mute=0

RF_TEST_IN_SEL = 4
RF_TEST_IN_PARAM&lt;3:0&gt;   test_in_a&lt;1&gt;      test_in_a&lt;0&gt;
x000                                     vga1_in_in_a     vga1_in_ip_a
x001                                     vga1_in_qn_a    vga1_in_qp_a
x010                                     vga2_in_in_a     vga2_in_ip_a
x011                                     vga2_in_qn_a    vga2_in_qp_a
x100                                     vga1_in_qn_a    vga1_in_ip_a
x101                                     vga2_in_qn_a    vga2_in_ip_a
other                                    High-Z               High-Z
</description>
	<bitRange>[12:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_TEST_IN_SEL</name>
	<description>Select an RF block to have its test input connected to the input testbus at pins P0[2] and P0[4]. NOTE: all 0 represent no testmode and the testbusses are floating except in reset state the testbuses are pulled to ground..
RF_TEST_IN_SEL=0001 : short test_in_a&lt;1:0&gt; to ground
RF_TEST_IN_SEL=0010 : test ADC inputs (details in RF_TEST_IN_PARAM)
RF_TEST_IN_SEL=0100 : test IFF inputs (details in RF_TEST_IN_PARAM) </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TEST_CTRL_REG</name>
	<description>Test Control Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ADPLL_SCAN_COMP_EN</name>
	<description>0: Normal operation
1: Enables the ADPLL scan compression mode.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_SCAN_TEST_EN</name>
	<description>0: Normal operation
1: Enables the ADPLL scan test mode.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CP_CAP_BIAS_TRIM</name>
	<description>Charge pump current source setting going to the LDO boost caps.
00: 10 nA (default)
01: 20 nA
10: 5 nA
11: 3.3 nA</description>
	<bitRange>[10:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_DUMMY_LOAD_ENABLE</name>
	<description>Static load on VDD.
NOTE: function inverted! (to improve default power up behaviour)
0: 5 uA
1: off</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_CAP_BYPASS</name>
	<description>Option to bypass LDO_CORE boost cap.
0: Normal functionality of boost cap.
1: Bypass boost cap (use it only when VBAT_LOW &gt; 2.2 V).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CAP_TEST_EN</name>
	<description>0: Normal Port function.
1: Shows xtal32m_cap_test_out output onto P0_1.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SHOW_DCDC</name>
	<description>0: Normal operation
1: The 8-bit DCDC test diagnostics signal is mapped to pins P0_8-P0_3 (bits [7:2]), P0_1 (bit [1]) and P0_0 (bit [0]).
Note: The selection of the specific diagnostic signals is peformed via DCDC_TEST1_REG[DCDC_DIG_TST_SEL] (see also the relative register description, defined under 'crg2632_dcdc_dig_00' sub-module of 'crg2632_00' block).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SHOW_POWER</name>
	<description>0: Normal operation
1: The following diagnostic signals are mapped to the pins of P0 port:
    P0_0 : CMP_VBAT_HIGH_NOK
    P0_1 : CMP_VBAT_HIGH_OK
    P0_3 : BGR_OK (BANDGAP OK signal)
    P0_4 : POR_VBAT_LOW_N
    P0_5 : POR_VBAT_HIGH_N
    P0_6 : LDO_LOW_OK
    P0_7 : LDO_CORE_OK
    P0_8 : ADC_LDO_OK
    P0_9 : XTAL32M_LDO_OK
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SHOW_CLOCKS</name>
	<description>0: normal port function
1: P0_1 = SYS_CLK (can be either RC32M, XTAL32M or LP_CLK)
    P0_3 = LP_CLK (can be either XTAL32K, RC32K or RCX)
    P0_4 = RC32K</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_TESTCTRL0_REG</name>
	<description>XTAL32M Test Control Register 0</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003400</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BIAS_SAH_HOLD_OVERRIDE</name>
	<description>The specific test mode overrules the XTAL bias sampling, as follows:
00 : Normal function (following radio enable)
01 : Continues tracking.
1x : Sample and hold.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_FREQ_TRIM_SW2_AMP</name>
	<description>Sets the threshold for the amplitude control OK detection.</description>
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_GM_CURRENT</name>
	<description>Enables the biasing of main oscillator output device.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_HOLD_AMP_REG_OVERRIDE</name>
	<description>The specific test mode overrules the amplitude detector.
00 : normal function (following radio enable)
01 : Continues tracking.
1x : HOLD mode.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_I2V_TO_TESTBUS</name>
	<description>The specific test mode enables the core amplifier.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_I2V_TO_TESTBUS_10X</name>
	<description>Test mode increasing the gain of the core amplifier.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_MAX_CURRENT</name>
	<description>Forces the maximum current in output gm core device.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_XTAL_DISCHARGE</name>
	<description>Software control mode, discharges the crystal.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCBLOCK_LV_MODE</name>
	<description>Low voltage comparator test mode</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIFFBUF_BYPASS</name>
	<description>Bypass comparator to use external input</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSC_TRIM_OPEN_DISABLE</name>
	<description>Varicap testmode, feedback resistors are disabled.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPIKE_FLT_DISABLE</name>
	<description>Disables DXTAL spike filter</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_TESTCTRL1_REG</name>
	<description>XTAL32M Test Control Register 1</description>
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>OSC_TRIM_CAP_BIAS</name>
	<description>0: Varicap bottom plate open.
1: Connect varicap bottom-plate to top plate.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCLK_SEL_ADPLL_ADC_TO_GPIO</name>
	<description>0: Select test output adpll to gpio when rfclk_adpll_to_gpio = 1.
1: Select test output adc to gpio when rfclk_adc_to_gpio = 1.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCLK_ADC_TO_GPIO</name>
	<description>Enables the test output of rfclk_adc to GPIO along with rfclk_sel_adc_adpll_to_gpio</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCLK_ADPLL_TO_GPIO</name>
	<description>Enables the test output of rfclk_adpll to GPIO, along with rfclk_sel_adc_adpll_to_gpio</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROG_VREF_SEL</name>
	<description>Enables the selection of programmable Vref for the XTAL32M LDO.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VARICAP_TEST_SEL_XTAL</name>
	<description>Selects XTAL_P or XTAL_N to varicap test output</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VARICAP_TEST_ENABLE</name>
	<description>Enables varicap test output to DCORE</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VREF_HOLD_OVERRIDE</name>
	<description>Overrides ldo_vref_hold. Writing a '1' will force a '0' to ldo_vref_hold.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DISABLE_TM_CLK</name>
	<description>This test mode disables tm_clk to enable the testing of the XTAL32M block.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPREG</name>
	<version>1.0</version>
	<description>GPREG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>14</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BLE_TIMER_REG</name>
	<description>BLE FINECNT sampled value while in deep sleep state.</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BLE_TIMER_DATA</name>
	<description>Operation depends on GP_CONTROL_REG-&gt;BLE_TIMER_DATA_CTRL.
If BLE_TIMER_DATA_CTRL = 0 then:
This register is located at the Always On Power Domain and it holds the automatically sampled value of the BLE FINECNT timer
The HW automatically samples the value into this register during the sequence of &quot;BLE Sleep On&quot; and restores automatically the value during the BLE Wake up sequence.
The Software may read and modify the value while the BLE is in Sleep state. While the BLE is awake, the value of the register has no meaning, while changing the value by writing another one will have no effect in the operation of the BLE core.
There is a constraint when the SW performs an write-read sequence where it has to inject a one cycle delay in between (e.g. write-NOP-read) in order to read back the correct value.
If BLE_TIMER_DATA_CTRL is non 0 then write operations have the same effect as when BLE_TIMER_DATA_CTRL=0, while for read operations:
BLE_TIMER_DATA_CTRL= 1: then reading BLE_TIMER_REG returns &quot;deepsldur[9:0]&quot;.
BLE_TIMER_DATA_CTRL= 2: then reading BLE_TIMER_REG returns &quot;deepsltime_samp[9:0]&quot;.
BLE_TIMER_DATA_CTRL= 3: then reading BLE_TIMER_REG returns &quot;{deep_sleep_stat_monitor, deepsltime_samp[18:10]}.
.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DEBUG_REG</name>
	<description>Various debug information register.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DEBUGS_FREEZE_EN</name>
	<description>Default '1', freezing of the on-chip timers is enabled when the Cortex-M0Plus is halted in DEBUG State.
If '0', freezing of the on-chip timers is depending on FREEZE_REG when the Cortex-M0Plus is halted in DEBUG State except the watchdog timer. The watchdog timer is always frozen when the Cortex-M0Plus is halted in DEBUG State. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_CONTROL_REG</name>
	<description>General purpose system control register.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BLE_TIMER_DATA_CTRL</name>
	<description>Refer to BLE_TIMER_REG.</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CPU_DMA_BUS_PRIO</name>
	<description>Controls the CPU DMA system bus priority:
If '0', the CPU has highest priority.
If '1', the DMA has highest priority.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_WAKEUP_LP_IRQ</name>
	<description>The current value of the BLE_WAKEUP_LP_IRQ interrupt request.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BLE_WAKEUP_REQ</name>
	<description>If '1', the BLE wakes up. Must be kept high at least for 1 low power clock period. 
If the BLE is in deep sleep state, then by setting this bit it will cause the wakeup LP IRQ to be asserted with a delay of 3 to 4 low power cycles.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_STATUS_REG</name>
	<description>General purpose system status register.</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CAL_PHASE</name>
	<description>If '1', it designates that the chip is in Calibration Phase i.e. the OTP has been initially programmed but no Calibration has occured. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_CTRL_REG</name>
	<description>Memory Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000080</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>ARB2_AHB2_WR_BUFF</name>
	<description>0: No AHB2 write access is buffered.
1: Currently a single AHB2 write access is buffered in arbiter two.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB2_AHB_WR_BUFF</name>
	<description>0: No AHB write access is buffered.
1: Currently a single AHB write access is buffered in arbiter two.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB1_AHB2_WR_BUFF</name>
	<description>0: No AHB2 write access is buffered.
1: Currently a single AHB2 write access is buffered in arbiter one.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB1_AHB_WR_BUFF</name>
	<description>0: No AHB write access is buffered.
1: Currently a single AHB write access is buffered in arbiter one.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAM_MARGIN</name>
	<description>RAM read and write margin control. Setting &quot;10&quot; is recommended.
00: Provides the most margin (slowest speed).
11: Provides the least margin (fastest speed).</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM_DST</name>
	<description>RAM Disable-Self-Time. When asserted high, overrides the self-timed circuitry and causes the read margin to be controlled by the falling clock edge. Requires RAM_MARGIN to be set to &quot;00&quot;.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ROM_MARGIN_EN</name>
	<description>ROM read margin enable.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ROM_MARGIN_CTRL</name>
	<description>ROM read margin control.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_FREEZE_REG</name>
	<description>Controls unfreezing of various timers/counters.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA continues, '0' is discarded. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WDOG</name>
	<description>If '1', the watchdog timer continues, '0' is discarded. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_BLETIM</name>
	<description>If '1', the the BLE master clock continues, '0' is discarded. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer (TIMER0) continues, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer continues, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_FREEZE_REG</name>
	<description>Controls freezing of various timers/counters.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA is frozen, '0' is discarded. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WDOG</name>
	<description>If '1', the watchdog timer is frozen, '0' is discarded. WATCHDOG_CTRL_REG[NMI_RST] must be '0' to allow the freeze function. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_BLETIM</name>
	<description>If '1', the BLE master clock is frozen, '0' is discarded. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer (TIMER0) is frozen, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer is frozen, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C</name>
	<version>1.0</version>
	<description>I2C registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>I2C_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_STOP_DET</name>
	<description>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. Reset value: 0x0</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP2_VERSION</name>
	<description>I2C Component2 Version Register</description>
	<addressOffset>0x000000fa</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003132</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP2_VERSION</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_PARAM1_REG</name>
	<description>Component Parameter Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP_PARAM1</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_PARAM2_REG</name>
	<description>Component Parameter Register 2</description>
	<addressOffset>0x000000f6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP_PARAM2</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_TYPE2_REG</name>
	<description>I2C Component2 Type Register</description>
	<addressOffset>0x000000fe</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004457</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP2_TYPE</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_TYPE_REG</name>
	<description>I2C Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000140</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP_TYPE</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_VERSION_REG</name>
	<description>I2C Component Version Register</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000302a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP_VERSION</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000007d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s)
Note: The actuall speed depends on the pcb traces capacitance as well as on the values of the external pull-up resistorts. For an exact speed match, trimming might be required, by adjusting the values of I2C_SS_SCL_HCNT_REG, I2C_SS_SCL_LCNT_REG, I2C_FS_SCL_HCNT_REG, I2C_FS_SCL_LCNT_REG registers. The reset values of those registers were calculated with the assumption of 4.3kOhms external pull-up resistors. </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received. If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. Reset value: 0x0</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received. STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a &quot;don't care&quot; because writes to this register are not required. In slave-transmitter mode, a &quot;0&quot; indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a &quot;1&quot; is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. //This bit enables/disables the transmit FIFO DMA channel. 0 = Transmit DMA disabled 1 = Transmit DMA enabled </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. 0 = Receive DMA disabled 1 = Receive DMA enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_ABORT</name>
	<description>0= ABORT not initiated or ABORT done
1= ABORT operation in progress
The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to
an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CTRL_ENABLE</name>
	<description>Controls whether the controller is enabled.
0: Disables the controller (TX and RX FIFOs are held in an erased state)
1: Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver
operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1.
When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1). </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000017</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the controller. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SDA_HOLD</name>
	<description>SDA Hold time</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.
It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000048</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000004f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Slave FSM is in IDLE state so the Slave part of the controller is not Active
1: Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Master FSM is in IDLE state so the Master part of the controller is not Active
1: Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0: Receive FIFO is not full
1: Receive FIFO is full </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0: Receive FIFO is empty
1: Receive FIFO is not empty </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0: Transmit FIFO is not empty
1: Transmit FIFO is empty </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0: Transmit FIFO is full
1: Transmit FIFO is not full </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPECIAL</name>
	<description>This bit indicates whether software performs a General Call or
START BYTE command.
0: ignore bit 10 GC_OR_START and use IC_TAR normally
1: perform special I2C command as specified in GC_OR_START
bit </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GC_OR_START</name>
	<description>If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1: START BYTE </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ABRT_SLVRD_INTX</name>
	<description>1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2IC_DATA_CMD register </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>1: Slave lost the bus while transmitting data to a remote master.
I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never &quot;owns&quot; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus. </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>1: Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB_LOST</name>
	<description>1: Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>1: User tries to initiate a Master operation with the Master mode disabled. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>1: Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>1: Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior). </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>1: the controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1). </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>1: the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>1: This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s). </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>1: Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>1: Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>1: Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 32 entries.. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>KBRD</name>
	<version>1.0</version>
	<description>KBRD registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>22</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GPIO_DEBOUNCE_REG</name>
	<description>debounce counter value for GPIO inputs</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>DEB_ENABLE_KBRD</name>
	<description>enables the debounce counter for the KBRD interface </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE4</name>
	<description>enables the debounce counter for GPIO IRQ4 </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE3</name>
	<description>enables the debounce counter for GPIO IRQ3 </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE2</name>
	<description>enables the debounce counter for GPIO IRQ2 </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE1</name>
	<description>enables the debounce counter for GPIO IRQ1 </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE0</name>
	<description>enables the debounce counter for GPIO IRQ0 </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_VALUE</name>
	<description>Keyboard debounce time if enabled. Generate KEYB_INT after specified time.
Debounce time: N*1 ms. N =0..63</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_INT_LEVEL_CTRL_REG</name>
	<description>high or low level select for GPIO interrupts</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>EDGE_LEVELn4</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ4 </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn3</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ3 </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn2</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ2 </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn1</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ1 </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn0</name>
	<description>0: do not wait for key release after interrupt was reset for GPIO IRQ0, so a new interrupt can be initiated immediately
1: wait for key release after interrupt was reset for IRQ0 </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL4</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ4 </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL3</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ3 </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL2</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ2 </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL1</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ1 </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL0</name>
	<description>0 = selected input will generate GPIO IRQ0 if that input is high.
1 = selected input will generate GPIO IRQ0 if that input is low. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ0_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ0_SEL</name>
	<description>input selection that can generate a GPIO interrupt
1: P0[0] is selected
2: P0[1] is selected
3: P0[2] is selected
4: P0[3] is selected
5: P0[4] is selected
6: P0[5] is selected
7: P0[6] is selected
8: P0[7] is selected
9: P0[8] is selected
10: P0[9] is selected
11: P0[10] is selected
12: P0[11] is selected
all others: no input selected </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ1_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ1</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ1_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ2_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ2</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ2_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ3_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ3</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ3_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ4_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ4</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ4_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_RESET_IRQ_REG</name>
	<description>GPIO interrupt reset register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_KBRD_IRQ</name>
	<description>writing a 1 to this bit will reset the KBRD IRQ.
Reading returns 0. </description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO4_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO4 IRQ.
Reading returns 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO3_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO3 IRQ.
Reading returns 0. </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO2_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO2 IRQ.
Reading returns 0. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO1_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO1 IRQ.
Reading returns 0. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO0_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO0 IRQ.
Reading returns 0. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>KBRD_CTRL_REG</name>
	<description>GPIO Kbrd control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>KBRD_REL</name>
	<description>0 = No interrupt on key release
1 = Interrupt also on key release (also debouncing if enabled) </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_LEVEL</name>
	<description>0 = enabled input will generate KBRD IRQ if that input is high.
1 = enabled input will generate KBRD IRQ if that input is low. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KEY_REPEAT</name>
	<description>While key is pressed, automatically generate repeating
KEYB_INT after specified time unequal to 0.
Repeat time: N*1 ms. N =1..63, N=0 disables the timer. </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>KBRD_IRQ_IN_SEL0_REG</name>
	<description>GPIO interrupt selection for KBRD_IRQ for P0</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>KBRD_P11_EN</name>
	<description>enable P0[11] for the keyboard interrupt </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P10_EN</name>
	<description>enable P0[10] for the keyboard interrupt </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P09_EN</name>
	<description>enable P0[9] for the keyboard interrupt </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P08_EN</name>
	<description>enable P0[8] for the keyboard interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P07_EN</name>
	<description>enable P0[7] for the keyboard interrupt </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P06_EN</name>
	<description>enable P0[6] for the keyboard interrupt </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P05_EN</name>
	<description>enable P0[5] for the keyboard interrupt </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P04_EN</name>
	<description>enable P0[4] for the keyboard interrupt </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P03_EN</name>
	<description>enable P0[3] for the keyboard interrupt </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P02_EN</name>
	<description>enable P0[2] for the keyboard interrupt </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P01_EN</name>
	<description>enable P0[1] for the keyboard interrupt </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P00_EN</name>
	<description>enable P0[0] for the keyboard interrupt </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>MBIST_SRAM12</name>
	<version>1.0</version>
	<description>MBIST_SRAM12 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003700</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>MBIST_SRAM12_ADDR_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_ADDR</name>
	<description>Returns the current address register in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM12_RD_LSB_REG</name>
	
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_LSB_DATA</name>
	<description>Returns the actual LSB read data in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM12_RD_MSB_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_MSB_DATA</name>
	<description>Returns the actual MSB read data in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM12_STATE_REG</name>
	
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_STATE</name>
	<description>Returns the current state in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>MBIST_SRAM3</name>
	<version>1.0</version>
	<description>MBIST_SRAM3 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003800</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>MBIST_SRAM3_ADDR_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_ADDR</name>
	<description>Returns the current address register in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM3_RD_LSB_REG</name>
	
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_LSB_DATA</name>
	<description>Returns the actual LSB read data in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM3_RD_MSB_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_MSB_DATA</name>
	<description>Returns the actual MSB read data in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM3_STATE_REG</name>
	
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_STATE</name>
	<description>Returns the current state in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>OTPC</name>
	<version>1.0</version>
	<description>OTPC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x07f40000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>36</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>OTPC_AHBADR_REG</name>
	<description>AHB master start address</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_AHBADR</name>
	<description>It is the AHB address used by the AHB master interface of the controller (the bits [15:2]). The bits [1:0] of the address are considered always as equal to zero.
The value of the register remains unchanged, by the internal logic of the controller. </description>
	<bitRange>[15:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_CELADR_REG</name>
	<description>OTP cell start address</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_CELADR</name>
	<description>Defines a word address inside the OTP cell that will be used during the AREAD mode and the OTP mirroring.</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_MODE_REG</name>
	<description>Mode register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_MODE_PRG_SEL</name>
	<description>Defines the part of the OTP cell that is programmed by the controller during the PROG mode, for each program request that is applied.
0x0 : Both normal and redundancy arrays are programmed. This is the normal way of programming.
0x1 : Only the normal array is programmed.
0x2 : Only the redundancy array is programmed.
0x3 : Reserved
The value of this configuration field can be modified only when the controller is in an inactive mode (DSTBY or STBY). The setting will take effect when will be enabled again the PROG mode.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_HT_MARG_EN</name>
	<description>Defines the temperature condition under which is performed a margin read. It affects only the initial margin read (RINI mode) and the programming verification margin read (PVFY).
0 : Regular temperature condition (less than 85&#176;C)
1 : High temperature condition (85&#176;C or more)
The value of this configuration field can be modified only when the controller is in an inactive mode (DSTBY or STBY). The selection will take effect at the next PVFY or RINI mode that will be enabled. The READ mode is not affected by the setting of this configuration bit.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_USE_TST_ROW</name>
	<description>Selects the memory area of the OTP cell that will be used.
0 - Uses the main memory area of the OTP cell
1 - Uses the test row of the OTP cell
The value of this configuration field can be modified only when the controller is in an inactive mode (DSTBY or STBY). The selection will take effect at the next programming or reading mode that will be enabled.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_MODE</name>
	<description>Defines the mode of operation of the OTPC controller. The encoding of the modes is as follows:
0x0: DSTBY. The OTP memory is in deep standby mode (power supply ON and internal LDO OFF).
0x1: STBY. The OTP memory is powered (power supply ON and internal LDO ON, but is not selected).
0x2: READ. The OTP memory is in the normal read mode.
0x3: PROG. The OTP memory is in programming mode.
0x4: PVFY. The OTP memory is in programming verification mode (margin read after programming).
0x5: RINI. The OTP memory is in initial read mode (initial margin read).
0x6: AREAD. Copying of data from the OTP memory to a system RAM by using the internal DMA. See also the registers OTPC_AHBADR_REG, OTPC_CELADR_REG and OTPC_NWORDS_REG.

Whenever the OTPC_MODE_REG[MODE] is changing, the status bit OTPC_STAT_REG[OTPC_STAT_MRDY] gets the value zero. The new mode will be ready for use when the OTPC_STAT_MRDY become again 1. During the mode transition the OTPC_MODE_REG[MODE] become read only. Do not try to use or change any function of the controller until the OTPC_STAT_MRDY bit to become equal to 1.
The data transferring that is performed by using the AREAD mode is completed when OTPC_STAT_MRDY becomes again 1. The mode change automatically to DSTBY with the completion of the transfer. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_NWORDS_REG</name>
	<description>Number of words</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_NWORDS</name>
	<description>The number of words (minus one) that will be copied by the AREAD mode. During mirroring, this register reflects the amount of data that will be copied. </description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_PADDR_REG</name>
	<description>The address of the word that will be programmed, when the PROG mode is used.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_PADDR</name>
	<description>The OTPC_PADDR_REG and the OTPC_PWORD_REG consist the PBUF buffer that keeps the information that will be programmed in the OTP, by using the PROG mode. The PBUF holds the address (OTPC_PADDR_REG) and the data (OTPC_PWORD_REG) of each of the programming requests that are applied in the OTP memory.
The OTPC_PADDR_REG refers to a word address. The OTPC_PADDR_REG has to be writen after the OTP_PWORD_REG and only if the OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY]=1. The register is read only for as long the PBUF is not empty (OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY]=0). A writting to the OTPC_PADDR_REG triggers the controller to start the programming procedure (only if the PROG mode is active).</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_PWORD_REG</name>
	<description>The 32-bit word that will be programmed, when the PROG mode is used.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_PWORD</name>
	<description>The OTPC_PADDR_REG and the OTPC_PWORD_REG consist the PBUF buffer that keeps the information that will be programmed in the OTP memory, by using the PROG mode. The PBUF holds the address (OTPC_PADDR_REG) and the data (OTPC_PWORD_REG) of each of the programming requests that are applied in the OTP memory.
The OTP_PWORD_REG must be written before the OTPC_PADDR_REG and only if OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY] = 1. The register is read only for as long the PBUF is not empty (OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY]=0). </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_STAT_REG</name>
	<description>Status register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_STAT_MRDY</name>
	<description>Indicates the progress of the transition from a mode of operation to a new mode of operation.
0 : There is a transition in progress in a new mode of operation . Wait until the transition to be completed.
1 : The transition to the new mode of operation has been completed. The function that has been enabled by the new mode can be used. A new mode can be applied.
This status bit gets the value zero every time where the OTPC_MODE_REG[MODE] is changing. Do not try to use or change any function of the controller until this status bit to become equal to 1.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PBUF_EMPTY</name>
	<description>Indicates the status of the programming buffer (PBUF).
0 : The PBUF contains the address and the data of a programming request. The OTPC_PADDR_REG and the OTPC_PWORD_REG should not be written as long as this status bit is zero.
1 : The PBUF is empty and a new programming request can be registered in the PBUF by using the OTPC_PADDR_REG and the OTPC_PWORD_REG registers.
This status bit gets the value zero every time where a programming is triggered by the OTPC_PADDR_REG (only if the PROG mode is active).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PRDY</name>
	<description>Indicates the state of the programming process.
0: The controller is busy. A programming is in progress.
1: The logic which performs programming is idle.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>OTPC_TIM1_REG</name>
	<description>Various timing parameters of the OTP cell.</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0999000f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_TIM1_US_T_CSP</name>
	<description>The number of microseconds (minus one) that are required after the selection of the OTP memory, until to be ready for programming. It must be :
- at least 10us
- no more than 100us</description>
	<bitRange>[30:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_US_T_CS</name>
	<description>The number of microseconds (minus one) that are required after the selection of the OTP memory, until to be ready for any kind of read. It must be at least 10us.</description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_US_T_PL</name>
	<description>The number of microseconds (minus one) that are required until to be enabled the LDO of the OTP. It must be at least 10us.</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_CC_T_RD</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval at least higher than 60ns. This timing parameter refers to the access time of the OTP memory.</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_CC_T_20NS</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval that is at least higher than 20 ns.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_CC_T_1US</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval equal to 1us. This setting affects all the timing parameters that refer to microseconds, due to that defines the correspondence of a microsecond to a number of hclk_c clock cycles.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_TIM2_REG</name>
	<description>Various timing parameters of the OTP cell.</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_TIM2_US_ADD_CC_EN</name>
	<description>Adds an additional hclk_c clock cycle at all the time intervals that count in microseconds.
0 : The extra hclk_c clock cycle is not applied
1 : The extra hclk_c clock cycle is applied</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_SAS</name>
	<description>The number of microseconds (minus one) that are required after the exit from the deep sleep standby mode and before to become ready to enter in an active mode (reading or programming). It must be at least 2us.</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PPH</name>
	<description>The number of microseconds (minus one) that are required after the last programming pulse and before to be disabled the programming mode in the OTP memory. It must be:
- at least 5us
- no more than 20us</description>
	<bitRange>[28:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_VDS</name>
	<description>The number of microseconds (minus one) that are required after the enabling of the power supply of the OTP memory and before to become ready for the enabling of the internal LDO. It must be at least 1us.</description>
	<bitRange>[23:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PPS</name>
	<description>The number of microseconds (minus one) that are required after the enabling of the programming in the OTP memory and before to be applied the first programming pulse. It must be :
- at least 5us
- no more than 20us</description>
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PPR</name>
	<description>The number of microseconds (minus one) for recovery after a programming sequence. It must be :
- at least 5us
- no more than 100us</description>
	<bitRange>[14:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PWI</name>
	<description>The number of microseconds (minus one) between two consecutive programming pulses. It must be :
- at least 1us
- no more than 5us</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PW</name>
	<description>The number of microseconds (minus one) that lasts the programming of each bit. It must be :
- at least 10us
- no more than 20us</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>PATCH</name>
	<version>1.0</version>
	<description>PATCH registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40080000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>208</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>PATCH_ADDR0_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR10_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR11_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR12_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR13_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR14_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR15_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR16_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR17_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR18_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR19_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR1_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR20_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<bitRange>[17:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR21_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<bitRange>[17:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR2_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR3_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR4_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR5_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR6_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR7_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR8_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR9_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_DATA20_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_DATA21_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_VALID_REG</name>
	<description>Validity Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_VALID</name>
	<description>Indicates which patch entry is valid. For example, when bit x is high it indicates that entry x is valid, i.e. the values of PATCH_ADDRx_REG / PATCH_DATAx_REG, are effective.
CAUTION: You should not activate two entries where the difference of the corresponding PATCH_ADDRx_REG is less than 12 bytes.</description>
	<bitRange>[21:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>QUADEC</name>
	<version>1.0</version>
	<description>QUADEC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>14</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>QDEC_CLOCKDIV_REG</name>
	<description>Clock divider register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000003e7</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>QDEC_PRESCALER_EN</name>
	<description>0 = no prescaler enabled
1 = in sleep and active mode, quadrature clock is divided by 2</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CLOCKDIV</name>
	<description>Contains the number of the input clock cycles minus one, that are required to generate one logic clock cycle.
Clock divider is bypassed when system runs at LP_CLK</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_CTRL2_REG</name>
	<description>Quad Decoder port selection register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000ed1</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>QDEC_CHZ_EVENT_MODE</name>
	<description>0 = Normal quadrature counting
1 = Counts rising and falling edge of both ports (if both ports change at the same time, counter increases by 1)</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHY_EVENT_MODE</name>
	<description>0 = Normal quadrature counting
1 = Counts rising and falling edge of both ports (if both ports change at the same time, counter increases by 1)</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHX_EVENT_MODE</name>
	<description>0 = Normal quadrature counting
1 = Counts rising and falling edge of both ports (if both ports change at the same time, counter increases by 1)</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHZ_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel Z
0: none
1: P0[2] -&gt; CHZ_A, P0[5] -&gt; CHZ_B
2: P0[1] -&gt; CHZ_A, P0[4] -&gt; CHZ_B
3: P0[3] -&gt; CHZ_A, P0[10] -&gt; CHZ_B
4: P0[6] -&gt; CHZ_A, P0[7] -&gt; CHZ_B
5: P0[8] -&gt; CHZ_A, P0[9] -&gt; CHZ_B
6: P0[0] -&gt; CHZ_A, P0[11] -&gt; CHZ_B
7: none</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHY_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel Y
0: none
1: P0[2] -&gt; CHY_A, P0[5] -&gt; CHY_B
2: P0[1] -&gt; CHY_A, P0[4] -&gt; CHY_B
3: P0[3] -&gt; CHY_A, P0[10] -&gt; CHY_B
4: P0[6] -&gt; CHY_A, P0[7] -&gt; CHY_B
5: P0[8] -&gt; CHY_A, P0[9] -&gt; CHY_B
6: P0[0] -&gt; CHY_A, P0[11] -&gt; CHY_B
7: none</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHX_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel X
0: none
1: P0[2] -&gt; CHX_A, P0[5] -&gt; CHX_B
2: P0[1] -&gt; CHX_A, P0[4] -&gt; CHX_B
3: P0[3] -&gt; CHX_A, P0[10] -&gt; CHX_B
4: P0[6] -&gt; CHX_A, P0[7] -&gt; CHX_B
5: P0[8] -&gt; CHX_A, P0[9] -&gt; CHX_B
6: P0[0] -&gt; CHX_A, P0[11] -&gt; CHX_B
7: none</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_CTRL_REG</name>
	<description>Quad Decoder control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000011</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>QDEC_IRQ_THRES</name>
	<description>Defines the number of events on either counter (X or Y or Z) that need to be reached before an interrupt is generated. Events are equal to QDEC_IRQ_THRES+1.</description>
	<bitRange>[10:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_IRQ_STATUS</name>
	<description>1 = Interrupt is occured.
0 = No interrupt pending
Write 1 will clear the pending interrupt </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_EVENT_CNT_CLR</name>
	<description>Writing 1 QDEC_EVENT_CNT_REG is cleared</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_IRQ_ENABLE</name>
	<description>0 = interrupt is masked
1 = interrupt is enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_EVENT_CNT_REG</name>
	<description>Event counter register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>QDEC_EVENT_CNT</name>
	<description>Gives the number of events at all channels.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_XCNT_REG</name>
	<description>Counter value of the X Axis</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QDEC_X_CNT</name>
	<description>Contains a signed value of the events. Zero when channel is disabled </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_YCNT_REG</name>
	<description>Counter value of the Y Axis</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QDEC_Y_CNT</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_ZCNT_REG</name>
	<description>Counter value of the Z Axis</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QDEC_Z_CNT</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFCU</name>
	<version>1.0</version>
	<description>RFCU registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40001000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>188</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RF_ADCI_DC_OFFSET_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00020100</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>ADC_OFFN_I_RD</name>
	<description>DC offset compensation in the I path (inverting input) in sign-magnitude notarion (i.e. -31 : 1 : 31 mV) </description>
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADC_OFFP_I_RD</name>
	<description>DC offset compensation in the I path (non-inverting input) in sign-magnitude notarion (i.e. -31 : 1 : 31 mV) </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_ADCQ_DC_OFFSET_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00020100</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>ADC_OFFN_Q_RD</name>
	<description>DC offset compensation in the Q path (inverting input) in sign-magnitude notarion (i.e. -31 : 1 : 31 mV) </description>
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADC_OFFP_Q_RD</name>
	<description>DC offset compensation in the Q path (non-inverting input) in sign-magnitude notarion (i.e. -31 : 1 : 31 mV) </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_ADC_CTRL1_REG</name>
	<description>ADC control register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00006001</resetMask>
	<fields><field>
	<name>ADC_SIGN</name>
	<description>Change polarity of ADC input. </description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_MUTE</name>
	<description>0: Normal operation
1: Short the inputs of the ADC (used for DC offset cal) </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_DC_OFFSET_SEL</name>
	<description>0: Normal operation (i.e. Use automatically calibrated value)
1: Use ADC_OFFx_y_WR to set the DC offset compensation values in the ADC (x = N or P, y = I or Q </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ADC_CTRL2_REG</name>
	<description>ADC control register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>ADC_OFFN_I_WR</name>
	<description>External value for the DC offset compensation in the I path negative side. With common mode input voltage at Vpwrp/2, this value is 512-ADC_OFFP_Q_WR. </description>
	<bitRange>[17:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_OFFP_I_WR</name>
	<description>External value for the DC offset compensation in the I path positive side. </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ADC_CTRL3_REG</name>
	<description>ADC control register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>ADC_OFFN_Q_WR</name>
	<description>External value for the DC offset compensation in the Q path negative side. With common mode input voltage at Vpwrp/2, this value is 512-ADC_OFFP_Q_WR. </description>
	<bitRange>[17:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_OFFP_Q_WR</name>
	<description>External value for the DC offset compensation in the Q path positive side. </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ADPLLDIG_CTRL_REG</name>
	<description>Adplldig specific settings register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x00000073</resetMask>
	<fields><field>
	<name>PWR_SW_TIM_CTRL</name>
	<description>Delay between power switch enable1,2 and status signal: Select any value between 1 to 8 us</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OPENLOOP_RDY_WR</name>
	<description>Overrule value for the openloop_rdy.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OPENLOOP_RDY_SEL</name>
	<description>Overrule the openloop_rdy from adplldig.
0: Normal function (default)
1: Overrule the openloop_rdy by OPENLOOP_RDY_WR</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ADPLLDIG_RFMON_CTRL_REG</name>
	<description>Settings for the ADPLLDIG RFMON block</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_RFMON_SPARE</name>
	
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_RFMON_MUX_SEL</name>
	<description>Mux select for the RFMON data
'b00x: dem_rfmon_data[31:0]
'b010: {dem_rfmon_data[31:16], adplldig_rfmon_data[15:0]}
'b011: {dem_rfmon_data[31:16], adplldig_rfmon_data[31:16]}
'b100: {adplldig_rfmon_data[31:16], dem_rfmon_data[15:0]}
'b101: {adplldig_rfmon_data[15:0], dem_rfmon_data[15:0]}
'b110: adplldig_rfmon_data
'b111: {adplldig_rfmon_data[15:0], adplldig_rfmon_data[31:16]}


Note:
- Please check bug2522A_018 (DEM 16Msps data need 16MHz RFCU clock).
- If only dem_rfmon_data[31:0] is to be monitored by writing 'b000 or 'b001, first the adplldig RFMON data should be disabled by setting ADPLL_RFPT_CTRL_REG[RFPT_MUX] to 0.</description>
	<bitRange>[3:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_SYNC_CLK_INV</name>
	<description>Invert the clock capturing adplldig_rfmon data
0: Do not invert
1: Invert (default)

Note:
Please check bug2522A_018 (DEM 16Msps data need 16MHz RFCU clock).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_AGC_EXT_LUT_REG</name>
	<description>AGC_LUT register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>AGC_EXT_LUT</name>
	<description>LUT for the AGC value, to be selected by dem_agc from the demodulator.
Gain settings 10, 11, 12 (so the last 3) use the value of gain setting 9</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ATTR_REG</name>
	<description>Radio attributes register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0c000820</resetValue>
	<resetMask>0x0f001f28</resetMask>
	<fields><field>
	<name>PA_POWER_SETTING</name>
	<description>Dynamic setting to control the PA power by enabling units
1 : minimum power

15: maximum power

IMPORTANT:
When the PA Pout ramping is enabled, this setting does NOT affect the Pout after the ramping has finished.
So, in evaluation, in order to sweep the Pout,
either disable the ramping (see RF_PA_CTRL_REG) and then sweep the PA_POWER_SETTING, or if you also want to monitor the ramping then first set the desired value to PA_POWER_SETTING and then enable the TX (repeat this cycle for every PA_POWER_SETTING to be measured). </description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIA_BIAS</name>
	<description>Tuning of the TIA bias current.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_BIAS</name>
	<description>Tuning of the Mixer bias current.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_POLARITY</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CALSTATE_REG</name>
	<description>cal_state read-out register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CALSTATE</name>
	<description>Value of the calstate state machine </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_CAL_CTRL_REG</name>
	<description>Calibration FSM control</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000017</resetMask>
	<fields><field>
	<name>DC_OFFSET_CAL_DIS</name>
	<description>Do not calibrate the VGA2 Offset during Cal cycle </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_CAL_CTRL_SPARE</name>
	<description>End of calibration trigger.
Reading returns the eo_cal status signal which can be cleared by writing to RF_IRQ_CTRL_REG.EO_CAL_CLEAR </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EO_CAL</name>
	<description>End of calibration trigger.
Reading returns the eo_cal status signal which can be cleared by writing to RF_IRQ_CTRL_REG.EO_CAL_CLEAR </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SO_CAL</name>
	<description>Start of calibration trigger.Writing a 1 starts calibration.1Reading returns the calibration status (1 = busy calibrating). </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RF_DIAGIRQ_CTRL_REG</name>
	<description>Control register for Diag IRQ</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7f7f7f7f</resetMask>
	<fields><field>
	<name>DIAG_BUS3_EDGE_SEL</name>
	<description>0 = rising edge
1 = falling edge</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS3_BIT_SEL</name>
	<description>Bit [0 to 7] selection in DIAG_BUS3</description>
	<bitRange>[29:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS3_SEL</name>
	<description>0 = BLE DIAG0
1 = BLEDIAG1
2 = RFCU DIAG
3 = DEMOD DIAG</description>
	<bitRange>[26:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS3_IRQ_MASK</name>
	<description>Enable diag_bus3 for IRQ generation</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS2_EDGE_SEL</name>
	<description>0 = rising edge
1 = falling edge</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS2_BIT_SEL</name>
	<description>Bit [0 to 7] selection in DIAG_BUS2</description>
	<bitRange>[21:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS2_SEL</name>
	<description>0 = BLE DIAG0
1 = BLEDIAG1
2 = RFCU DIAG
3 = DEMOD DIAG</description>
	<bitRange>[18:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS2_IRQ_MASK</name>
	<description>Enable diag_bus 2 for IRQ generation</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS1_EDGE_SEL</name>
	<description>0 = rising edge
1 = falling edge</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS1_BIT_SEL</name>
	<description>Bit [0 to 7] selection in DIAG_BUS1</description>
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS1_SEL</name>
	<description>0 = BLE DIAG0
1 = BLEDIAG1
2 = RFCU DIAG
3 = DEMOD DIAG</description>
	<bitRange>[10:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS1_IRQ_MASK</name>
	<description>Enable diag_bus 1 for IRQ generation</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS0_EDGE_SEL</name>
	<description>0 = rising edge
1 = falling edge</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS0_BIT_SEL</name>
	<description>Bit [0 to 7] selection in DIAG_BUS0</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS0_SEL</name>
	<description>0 = BLE DIAG0
1 = BLEDIAG1
2 = RFCU DIAG
3 = DEMOD DIAG</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS0_IRQ_MASK</name>
	<description>Enable diag_bus 0 for IRQ generation</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_DIAGIRQ_STAT_REG</name>
	<description>RF DIAG IRQ Status register</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>DIAGIRQ_STAT</name>
	<description>RF DIAG IRQ status register</description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_IFF_CTRL_REG</name>
	<description>IFF control register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00007ff3</resetMask>
	<fields><field>
	<name>IFF_DCOC_DAC_REFCUR_CTRL</name>
	<description>Controls the DCOC DAC refcurrent and thus the range of correctable dc offsets at the input of IFF.
Higher value means higher DC offsets can be compensated, but at the same time the LSB (so residual DC offset) increases.
DCOC DAC is 8 bits in D2632

0: 1x current (ibias 2.5uA), +-24mV input offset range
1: 2x current (ibias 5.0uA), +-48mV input offset range (Default)
2: 3x current (ibias 7.5uA), +-72mV input offset range
3: 4x current (ibias 10.0uA), +-96mV input offset range


Value for DCBETA depends on the IFF DCOC DAC REF CURR
setting, ratio_580_refcurr, preferred_settingRF_DC_OFFSET_CTRL3_REG
0, 1x, 0xDCE4
1, 2x, 0xEEF2
2, 3x, 0xF4F7
3, 4x, 0xF7F9</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_COMPLEX_DIS</name>
	<description>Put IF-filter in lowpass configuration </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_IFF_CTRL_SPARE</name>
	<description>Spare register bits</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_DCOC_DAC_DIS</name>
	<description>Disable the DC offset current DAC </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IF_MUTE</name>
	<description>'0': normal operation;
'1': Mute IFF by short circuit of VGA1 input.
Note: set TGATE_MIXER_IF to '0' for isolation from the IRM </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IF_CAL_TRIM</name>
	<description>Current value applied to IF_CAL_CAP</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_IO_CTRL_REG</name>
	<description>IO control register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x00000f0f</resetMask>
	<fields><field>
	<name>RFIO_TUNE_CAP_TRIM_TX</name>
	<description>Trims the tuning cap for TX mode.
Step = 20fF.
0: Minimum cap (all caps off)

7: Maximum cap (all caps on)</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_TUNE_CAP_TRIM_RX</name>
	<description>Trims the RX tuning cap for RX mode.
Step = 20fF.
0: Minimum cap (all caps off)

7: Maximum cap (all caps on)</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_IRQ_CTRL_REG</name>
	<description>IRQ clear register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>EO_CAL_CLEAR</name>
	<description>Writing any value to this bit clears eo_cal interrupt. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RF_LDO_CTRL_REG</name>
	<description>Controls for LDO</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00190333</resetValue>
	<resetMask>0x3f1f0fff</resetMask>
	<fields><field>
	<name>LDO_DCO_HOLD_OVR_EN</name>
	<description>When equals to '1', enables overriding capability for LDO_DCO_HOLD_VREF</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DCO_HOLD_OVR_VAL</name>
	<description>Override value for LDO_DTC_HOLD_VREFwhen LDO_DTC_OVR_EN = 1</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DTC_HOLD_OVR_EN</name>
	<description>When equals to '1', enables overriding capability for LDO_DTC_HOLD_VREF</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DTC_HOLD_OVR_VAL</name>
	<description>Override value for LDO_DTC_HOLD_VREFwhen LDO_DTC_OVR_EN = 1</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RADIO_HOLD_OVR_EN</name>
	<description>When equals to '1', enables overriding capability for LDO_RADIO_HOLD_VREF</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RADIO_HOLD_OVR_VAL</name>
	<description>Override value for LDO_RADIO_HOLD_VREFwhen LDO_RADIO_OVR_EN = 1</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VREF_SMPL_TIME</name>
	<description>Time (in us) to sample the VREF node after each LDO is enabled</description>
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DCO_CONT_ENABLE</name>
	<description>Radio LDO continuous enable</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DCO_LEVEL</name>
	<description>Level for Radio LDO</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DTC_CONT_ENABLE</name>
	<description>Radio LDO continuous enable</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DTC_LEVEL</name>
	<description>Level for Radio LDO</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RADIO_CONT_ENABLE</name>
	<description>Radio LDO continuous enable</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RADIO_LEVEL</name>
	<description>Level for Radio LDO</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_LDO_STATUS_REG</name>
	<description>Read out value of LDO enables</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>ldo_dtc_vref_hold_rd</name>
	<description>ADPLLDIG LDO zero enable bit.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ldo_dco_vref_hold_rd</name>
	<description>ADPLLDIG LDO zero enable bit.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ldo_radio_vref_hold_rd</name>
	<description>ADPLLDIG LDO zero enable bit.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ldo_dtc_en_rd</name>
	<description>ADPLLDIG LDO zero enable bit.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ldo_dco_en_rd</name>
	<description>ADPLLDIG LDO zero enable bit.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADPLLDIG_LDO_ZERO_EN_RD</name>
	<description>ADPLLDIG LDO zero enable bit.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADPLLDIG_LDO_EN_RD</name>
	<description>ADPLLDIG LDO enable bit.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RADIO_LDO_ZERO_EN_RD</name>
	<description>Radio LDO zero enable bit.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RADIO_LDO_EN_RD</name>
	<description>Radio LDO enable bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_LDO_VREF_SEL_REG</name>
	<description>Vref sel control register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>RF_LDO_DCO_VREF_SEL</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_LDO_DTC_VREF_SEL</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_LDO_RADIO_VREF_SEL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_LNA_CTRL1_REG</name>
	<description>LNA control register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x01084210</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields><field>
	<name>LNA_TRIM_GAIN4_HP</name>
	<description>High performance LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 1 and lna_gain_sel &gt; 3)</description>
	<bitRange>[24:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN3_HP</name>
	<description>High performance LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 1 and lna_gain_sel = 3)</description>
	<bitRange>[19:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN2_HP</name>
	<description>High performance LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 1 and lna_gain_sel = 2)</description>
	<bitRange>[14:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN1_HP</name>
	<description>High performance LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 1 and lna_gain_sel = 1)</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN0_HP</name>
	<description>High performance LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 1 and lna_gain_sel = 0)
The mode for HP is hardwired to 3.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_LNA_CTRL2_REG</name>
	<description>LNA control register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00d6b5ad</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields><field>
	<name>LNA_TRIM_GAIN4_LP</name>
	<description>Low power LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel &gt; 3)</description>
	<bitRange>[24:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN3_LP</name>
	<description>Low power LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel = 3)</description>
	<bitRange>[19:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN2_LP</name>
	<description>Low power LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel = 2)</description>
	<bitRange>[14:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN1_LP</name>
	<description>Low power LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel = 1)</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN0_LP</name>
	<description>Low power LNA gm trim bias settings for CN
00: Lowest gm trim
10: Nominal gm trim
1F: Highest gm trim
(Used as gm trim bias value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel = 0)</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_LNA_CTRL3_REG</name>
	<description>LNA control register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00111114</resetValue>
	<resetMask>0x0333333f</resetMask>
	<fields><field>
	<name>LNA_SPARE</name>
	<description>Spare bits for LNA.</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN4_LP</name>
	<description>Low power LNA mode setting
(Used as lna_mode value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel &gt; 3)</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN3_LP</name>
	<description>Low power LNA mode setting
(Used as lna_mode value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel = 3)</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN2_LP</name>
	<description>Low power LNA mode setting
(Used as lna_mode value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel = 2)</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN1_LP</name>
	<description>Low power LNA mode setting
(Used as lna_mode value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel = 1)</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN0_LP</name>
	<description>Low power LNA mode setting
(Used as lna_mode value if RF_ATTR_REG[LNA_PWR_MODE] = 0 and lna_gain_sel = 0)</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_CASC</name>
	<description>Trims the cascode voltages.
0: lower voltage

7: higher voltage</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_MIXER_CTRL1_REG</name>
	<description>Mixer control register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x010f010f</resetValue>
	<resetMask>0x01ff01ff</resetMask>
	<fields><field>
	<name>MIXER_IP2_DAC_Q_TRIM</name>
	<description>Trims the IN DAC.
Step = 3.9mV (LSB) for MIXER_IP2_DAC_EXTEND (Bit 25) = 0
Step = 2* 3.9mV (LSB) for MIXER_IP2_DAC_EXTEND (Bit 25) = 1
0: Lowest voltage

63: Highest voltage

Bit 25 (MIXER_IP2_DAC_EXTEND) description needs to be added to this register.</description>
	<bitRange>[24:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIXER_IP2_DAC_I_TRIM</name>
	<description>Trims the QN DAC.
Step = 3.9mV (LSB) for MIXER_IP2_DAC_EXTEND = 0
Step = 2* 3.9mV (LSB) for MIXER_IP2_DAC_EXTEND = 1
0: Lowest voltage

63: Highest voltage

Bit 25 (MIXER_IP2_DAC_EXTEND) description needs to be added to this register.</description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_MIXER_CTRL2_REG</name>
	<description>Mixer control register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00010f0f</resetMask>
	<fields><field>
	<name>MIX_CAL_SELECT</name>
	<description>0: use IF_CAL_CAP_1M/2M_SET1, depending on mode. MIX_CAL_CAP_WR is added as offset.
1: use MIX_CAL_CAP_WR directly</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_CAL_CAP_WR_2M</name>
	<description>External value for calibration of mixer pole capacitance for 2M mode.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_CAL_CAP_WR_1M</name>
	<description>External value for calibration of mixer pole capacitance for 1M mode.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_OVERRULE_REG</name>
	<description>Overrule register</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>RX_EN_OVR</name>
	<description>Overrule RX_EN
'b01: disabled.
'b1x: enabled.
'b00: normal function</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_EN_OVR</name>
	<description>Overrule TX_EN
'b01: disabled.
'b1x: enabled.
'b00: normal function</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_PA_CTRL_REG</name>
	<description>PA control register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000300</resetValue>
	<resetMask>0x0000033f</resetMask>
	<fields><field>
	<name>PA_RAMP_STEP_SPEED</name>
	<description>00 no ramping
01 ramp step 125 ns
10 ramp step 250 ns
11 ramp step 500 ns
</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIM_DUTY_NEG</name>
	<description>Trims the duty-cycle (current starving) resistor at the nmos side
0: lowest resistance (shorted, fastest falling edge)

7: max resistance (slowest falling edge)</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIM_DUTY_POS</name>
	<description>Trims the duty-cycle (current starving) resistor at the pmos side
0: lowest resistance (shorted, fastest rising edge)

7: max resistance (slowest rising edge)</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_RADIO_INIT_REG</name>
	<description>Radio initialization register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x010303ff</resetMask>
	<fields><field>
	<name>RADIO_INIT_AUTOCLEAR</name>
	<description>LDO mode
0: Clear ADPLLDIG_LDO_EN from FW.
1: Auto-clear ADPLLDIG_LDO_EN on radio_busy negedge if there is no package in IFS.</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_HCLK_DIS</name>
	<description>Disable adplldig hclk.
0: Do nothing
1: Disable
(It is auto-cleared when ADPLLDIG_HCLK_EN is set to 1)
Remark: Since ADPLLDIG_HCLK_EN has higher priority over ADPLLDIG_HCLK_DIS, ADPLLDIG_HCLK_DIS bit-field cannot be set to 1 with &quot;SetBits()&quot; commands, which access the two bit-fields at the same time. To be able to ADPLLDIG_HCLK_DIS bit-field to 1, &quot;SetByte()&quot; command should be used.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_REGS_RDY</name>
	<description>ADPLLDIG regs loading status bit
(Auto-clear to 0 at phy_busy pos-edge or when ADPLLDIG LDO is off)
0: Loading preferred values is not finished.
1: Loading preferred values is finished.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_HCLK_EN</name>
	<description>Enable adplldig hclk.
0: Disable
1: Enable
(It is auto-cleared when ADPLLDIG_HCLK_DIS is set to 1)</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_HRESET_N</name>
	<description>Reset Adplldig register file
0: Reset state.
1: Reset is released.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_LDO_EN_WR</name>
	<description>ADPLLDIG LDO EN overrule value.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_LDO_EN_SEL</name>
	<description>Select ADPLLDIG_LDO_EN_WR.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_PWR_SW1_EN</name>
	<description>ADPLLDIG LDO enable bit.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_LDO_EN_WR</name>
	<description>Radio LDO EN overrule value.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_LDO_EN_SEL</name>
	<description>Select RADIO_LDO_EN_WR.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_LDO_EN</name>
	<description>Radio LDO enable bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_RFCU_CTRL_REG</name>
	<description>RFCU control register</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RF_RFCU_CLK_DIV</name>
	<description>Divide the RFCU clock by 2.
0: 16 MHz
1: 8 MHz (default)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_SCAN_FEEDBACK_REG</name>
	<description>scan feedback register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	
</register><register>
	<name>RF_SPARE_REG</name>
	<description>Spare register for radio</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x1fffffff</resetMask>
	<fields><field>
	<name>RF_SPARE_IN_EN</name>
	<description>Enable reading of the spare inputs from radio.</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_SPARE_IN</name>
	<description>Spare inputs from radio.</description>
	<bitRange>[27:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RF_SPARE_BITS_HV</name>
	<description>Spare bits for High voltage.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_SPARE_BITS</name>
	<description>Spare bits.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFCU_POWER</name>
	<version>1.0</version>
	<description>RFCU_POWER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40001200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>400</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RF_ALWAYS_EN1_REG</name>
	
	<addressOffset>0x00000180</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ALW_EN_ADPLLDIG_EN</name>
	
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLLDIG_RST</name>
	
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_CLK_EN</name>
	
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_DCO_EN</name>
	
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADC_EN</name>
	
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADC_CLK_EN</name>
	
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_IFF_BIAS_SH_OPEN</name>
	
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_IFF_EN</name>
	
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_MIX_BIAS_SH_OPEN</name>
	
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_MIX_EN</name>
	
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LNA_CGM_EN</name>
	
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LNA_CORE_EN</name>
	
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_PA_EN</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_PA_RAMP_EN</name>
	
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_BIAS_SH_OPEN</name>
	
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_BIAS_EN</name>
	
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_TX_HARM_EN</name>
	
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_TX_EN</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_RX_EN</name>
	
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLLDIG_LDO_LP</name>
	
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLLDIG_LDO_ACTIVERDY</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LNA_LDO_ZERO</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LDO_ZERO_EN</name>
	
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_DCO_LDO_EN</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_DTC_LDO_EN</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_TDC_LDO_EN</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_IFFADC_LDO_EN</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_IFF_LDO_EN</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_MIX_LDO_EN</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LNA_LDO_EN</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_PA_LDO_EN</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_LDO_EN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ALWAYS_EN2_REG</name>
	
	<addressOffset>0x00000184</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>ALW_EN_SPARE5</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_SPARE4</name>
	
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_SPARE3</name>
	
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_SPARE2</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_SPARE1</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_RDY_FOR_DIV</name>
	
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_PHY_RDY4BS</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_DEM_SIGDETECT_EN</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_DEM_AGC_UNFREEZE_EN</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_DEM_DC_PARCAL_EN</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_DEM_EN</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_CAL_EN</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_LOBUF_PA_EN</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_PAIN_EN</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLLDIG_RX_EN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_10_REG</name>
	
	<addressOffset>0x00000124</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c16</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_11_REG</name>
	
	<addressOffset>0x00000128</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000081a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_tx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_tx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_12_REG</name>
	
	<addressOffset>0x0000012c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000e1a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_13_REG</name>
	
	<addressOffset>0x00000130</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000220</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_14_REG</name>
	
	<addressOffset>0x00000134</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000a20</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_15_REG</name>
	
	<addressOffset>0x00000138</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000426</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_16_REG</name>
	
	<addressOffset>0x0000013c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000430</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_17_REG</name>
	
	<addressOffset>0x00000140</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000837</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_18_REG</name>
	
	<addressOffset>0x00000144</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000846</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_19_REG</name>
	
	<addressOffset>0x00000148</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000850</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_1_REG</name>
	
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000400</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/so_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_20_REG</name>
	
	<addressOffset>0x0000014c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000125a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_21_REG</name>
	
	<addressOffset>0x00000150</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_22_REG</name>
	
	<addressOffset>0x00000154</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_23_REG</name>
	
	<addressOffset>0x00000158</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_24_REG</name>
	
	<addressOffset>0x0000015c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_25_REG</name>
	
	<addressOffset>0x00000160</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_26_REG</name>
	
	<addressOffset>0x00000164</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_27_REG</name>
	
	<addressOffset>0x00000168</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_28_REG</name>
	
	<addressOffset>0x0000016c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_29_REG</name>
	
	<addressOffset>0x00000170</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_2_REG</name>
	
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c00</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/so_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_30_REG</name>
	
	<addressOffset>0x00000174</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_31_REG</name>
	
	<addressOffset>0x00000178</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_3_REG</name>
	
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000408</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/so_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_4_REG</name>
	
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c08</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_5_REG</name>
	
	<addressOffset>0x00000110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000212</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_6_REG</name>
	
	<addressOffset>0x00000114</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000a12</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_7_REG</name>
	
	<addressOffset>0x00000118</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000414</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_tx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_tx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_8_REG</name>
	
	<addressOffset>0x0000011c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c14</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_9_REG</name>
	
	<addressOffset>0x00000120</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000416</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG0_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_LDO_EN_DCF_TX</name>
	<description>DCF timer for rfio_ldo_en in tx mode.</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_LDO_EN_DCF_RX</name>
	<description>DCF timer for rfio_ldo_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG10_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LNA_LDO_ZERO_DCF_TX</name>
	<description>DCF timer for lna_ldo_zero in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_LDO_ZERO_DCF_RX</name>
	<description>DCF timer for lna_ldo_zero in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG11_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000c5</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_LDO_ACTIVERDY_DCF_TX</name>
	<description>DCF timer for adplldig_ldo_activerdy in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_LDO_ACTIVERDY_DCF_RX</name>
	<description>DCF timer for adplldig_ldo_activerdy in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG12_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000018b</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_LDO_LP_DCF_TX</name>
	<description>DCF timer for adplldig_ldo_lp in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_LDO_LP_DCF_RX</name>
	<description>DCF timer for adplldig_ldo_lp in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG13_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_RX_EN_DCF_TX</name>
	<description>DCF timer for rfio_rx_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_RX_EN_DCF_RX</name>
	<description>DCF timer for rfio_rx_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG14_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001c0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_TX_EN_DCF_TX</name>
	<description>DCF timer for rfio_tx_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_TX_EN_DCF_RX</name>
	<description>DCF timer for rfio_tx_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG15_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001c0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_TX_HARM_EN_DCF_TX</name>
	<description>DCF timer for rfio_tx_harm_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_TX_HARM_EN_DCF_RX</name>
	<description>DCF timer for rfio_tx_harm_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG16_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000008f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_BIAS_EN_DCF_TX</name>
	<description>DCF timer for rfio_bias_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_BIAS_EN_DCF_RX</name>
	<description>DCF timer for rfio_bias_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG17_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000210</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_BIAS_SH_OPEN_DCF_TX</name>
	<description>DCF timer for rfio_bias_sh_open in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_BIAS_SH_OPEN_DCF_RX</name>
	<description>DCF timer for rfio_bias_sh_open in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG18_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001a0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PA_RAMP_EN_DCF_TX</name>
	<description>DCF timer for pa_ramp_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PA_RAMP_EN_DCF_RX</name>
	<description>DCF timer for pa_ramp_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG19_REG</name>
	
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001c0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PA_EN_DCF_TX</name>
	<description>DCF timer for pa_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PA_EN_DCF_RX</name>
	<description>DCF timer for pa_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG1_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PA_LDO_EN_DCF_TX</name>
	<description>DCF timer for pa_ldo_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PA_LDO_EN_DCF_RX</name>
	<description>DCF timer for pa_ldo_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG20_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LNA_CORE_EN_DCF_TX</name>
	<description>DCF timer for lna_core_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_CORE_EN_DCF_RX</name>
	<description>DCF timer for lna_core_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG21_REG</name>
	
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LNA_CGM_EN_DCF_TX</name>
	<description>DCF timer for lna_cgm_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_CGM_EN_DCF_RX</name>
	<description>DCF timer for lna_cgm_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG22_REG</name>
	
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>MIX_EN_DCF_TX</name>
	<description>DCF timer for mix_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_EN_DCF_RX</name>
	<description>DCF timer for mix_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG23_REG</name>
	
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>MIX_BIAS_SH_OPEN_DCF_TX</name>
	<description>DCF timer for mix_bias_sh_open in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_BIAS_SH_OPEN_DCF_RX</name>
	<description>DCF timer for mix_bias_sh_open in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG24_REG</name>
	
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>IFF_EN_DCF_TX</name>
	<description>DCF timer for iff_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_EN_DCF_RX</name>
	<description>DCF timer for iff_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG25_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>IFF_BIAS_SH_OPEN_DCF_TX</name>
	<description>DCF timer for iff_bias_sh_open in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_BIAS_SH_OPEN_DCF_RX</name>
	<description>DCF timer for iff_bias_sh_open in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG26_REG</name>
	
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADC_CLK_EN_DCF_TX</name>
	<description>DCF timer for adc_clk_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_CLK_EN_DCF_RX</name>
	<description>DCF timer for adc_clk_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG27_REG</name>
	
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADC_EN_DCF_TX</name>
	<description>DCF timer for adc_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_EN_DCF_RX</name>
	<description>DCF timer for adc_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG28_REG</name>
	
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_DCO_EN_DCF_TX</name>
	<description>DCF timer for adpll_dco_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_DCO_EN_DCF_RX</name>
	<description>DCF timer for adpll_dco_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG29_REG</name>
	
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_CLK_EN_DCF_TX</name>
	<description>DCF timer for adpll_clk_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_CLK_EN_DCF_RX</name>
	<description>DCF timer for adpll_clk_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG2_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LNA_LDO_EN_DCF_TX</name>
	<description>DCF timer for lna_ldo_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_LDO_EN_DCF_RX</name>
	<description>DCF timer for lna_ldo_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG30_REG</name>
	
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000107</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_RST_DCF_TX</name>
	<description>DCF timer for adplldig_rst in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_RST_DCF_RX</name>
	<description>DCF timer for adplldig_rst in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG31_REG</name>
	
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000149</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_EN_DCF_TX</name>
	<description>DCF timer for adplldig_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_EN_DCF_RX</name>
	<description>DCF timer for adplldig_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG32_REG</name>
	
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_RX_EN_DCF_TX</name>
	<description>DCF timer for adplldig_rx_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_RX_EN_DCF_RX</name>
	<description>DCF timer for adplldig_rx_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG33_REG</name>
	
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001e0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_PAIN_EN_DCF_TX</name>
	<description>DCF timer for adplldig_pain_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_PAIN_EN_DCF_RX</name>
	<description>DCF timer for adplldig_pain_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG34_REG</name>
	
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001c0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_LOBUF_PA_EN_DCF_TX</name>
	<description>DCF timer for adpll_lobuf_pa_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_LOBUF_PA_EN_DCF_RX</name>
	<description>DCF timer for adpll_lobuf_pa_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG35_REG</name>
	
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000294</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>CAL_EN_DCF_TX</name>
	<description>DCF timer for cal_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CAL_EN_DCF_RX</name>
	<description>DCF timer for cal_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG36_REG</name>
	
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000011</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>DEM_EN_DCF_TX</name>
	<description>DCF timer for dem_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_EN_DCF_RX</name>
	<description>DCF timer for dem_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG37_REG</name>
	
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE_DEM_DC_PARCAL_DCF_TX</name>
	<description>Spare DCF timer in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_DC_PARCAL_EN_DCF_RX</name>
	<description>DCF timer for DC partial Calibration enable in rx mode. It is OR'd with the relevant register bit that enables the partial calibration.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG38_REG</name>
	
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000011</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE_DEM_AGC_UNFREEZE_EN_DCF_TX</name>
	<description>Spare DCF timer in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_AGC_UNFREEZE_EN_DCF_RX</name>
	<description>DCF timer for unfreezing the AGC in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG39_REG</name>
	
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000013</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE_DEM_SIGDETECT_EN_DCF_TX</name>
	<description>Spare DCF timer in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_SIGDETECT_EN_DCF_RX</name>
	<description>DCF timer for enabling the signal_detect in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG3_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>MIX_LDO_EN_DCF_TX</name>
	<description>DCF timer for mix_ldo_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_LDO_EN_DCF_RX</name>
	<description>DCF timer for mix_ldo_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG40_REG</name>
	
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000253</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PHY_RDY4BS_DCF_TX</name>
	<description>DCF timer for PHY_RDY4BS in tx mode.</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PHY_RDY4BS_DCF_RX</name>
	<description>DCF timer for PHY_RDY4BS in rx mode.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG41_REG</name>
	
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000c5</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_RDY_FOR_DIV_DCF_TX</name>
	<description>&quot;Ready for the Dividers&quot; DCF timer in tx mode.</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_RDY_FOR_DIV_DCF_RX</name>
	<description>&quot;Ready for the Dividers&quot; DCF timer in tx mode.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG42_REG</name>
	
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE1_DCF_TX</name>
	<description>Spare DCF timer in tx mode.</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE1_DCF_RX</name>
	<description>Spare DCF timer in rx mode.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG43_REG</name>
	
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE2_DCF_TX</name>
	<description>Spare DCF timer in tx mode.</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE2_DCF_RX</name>
	<description>Spare DCF timer in rx mode.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG44_REG</name>
	
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE3_DCF_TX</name>
	<description>Spare DCF timer in tx mode.</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE3_DCF_RX</name>
	<description>Spare DCF timer in rx mode.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG45_REG</name>
	
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE4_DCF_TX</name>
	<description>Spare DCF timer in tx mode.</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE4_DCF_RX</name>
	<description>Spare DCF timer in rx mode.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG46_REG</name>
	
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE5_DCF_TX</name>
	<description>Spare DCF timer in tx mode.</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE5_DCF_RX</name>
	<description>Spare DCF timer in rx mode.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG4_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>IFF_LDO_EN_DCF_TX</name>
	<description>DCF timer for iff_ldo_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_LDO_EN_DCF_RX</name>
	<description>DCF timer for iff_ldo_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG5_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>IFFADC_LDO_EN_DCF_TX</name>
	<description>DCF timer for iffadc_ldo_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFFADC_LDO_EN_DCF_RX</name>
	<description>DCF timer for iffadc_ldo_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG6_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_TDC_LDO_EN_DCF_TX</name>
	<description>DCF timer for adpll_tdc_ldo_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_TDC_LDO_EN_DCF_RX</name>
	<description>DCF timer for adpll_tdc_ldo_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG7_REG</name>
	
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_DTC_LDO_EN_DCF_TX</name>
	<description>DCF timer for adpll_dtc_ldo_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_DTC_LDO_EN_DCF_RX</name>
	<description>DCF timer for adpll_dtc_ldo_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG8_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_DCO_LDO_EN_DCF_TX</name>
	<description>DCF timer for adpll_dco_ldo_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_DCO_LDO_EN_DCF_RX</name>
	<description>DCF timer for adpll_dco_ldo_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG9_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LDO_ZERO_EN_DCF_TX</name>
	<description>DCF timer for ldo_zero_en in tx mode</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_ZERO_EN_DCF_RX</name>
	<description>DCF timer for ldo_zero_en in rx mode</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_PORT_EN_REG</name>
	
	<addressOffset>0x00000188</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RF_PORT4_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_31_REG</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT4_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_31_REG</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT3_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_30_REG</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT3_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_30_REG</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT2_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_29_REG</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT2_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_29_REG</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT1_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_28_REG</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT1_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_28_REG</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT0_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_27_REG</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT0_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_27_REG</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_PORT_POL_REG</name>
	
	<addressOffset>0x0000018c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>RF_PORT4_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT3_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT2_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT1_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT0_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFMON</name>
	<version>1.0</version>
	<description>RFMON registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>22</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RFMON_ADDR_REG</name>
	<description>AHB master start address</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_ADDR</name>
	<description>It is the bits [15:2] of base address that is used by the AHB master interface of the controller. Defines the AHB address from where the controller will start to stores data. The bits [1:0] of the address are considered always 0.</description>
	<bitRange>[15:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RFMON_CRV_ADDR_REG</name>
	<description>AHB master current address</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_CRV_ADDR</name>
	<description>It is the bits [15:2] of AHB address that will be used by the controller in the next memory access. The bits [1:0] are always 0.</description>
	<bitRange>[15:2]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RFMON_CRV_LEN_REG</name>
	<description>The remaining data to be transferred</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_CRV_LEN</name>
	<description>Indicates the number of words (minus 1) that remain to be transfered.</description>
	<bitRange>[13:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RFMON_CTRL_REG</name>
	<description>Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_CIRC_EN</name>
	<description>Write with 1 to enable the circular mode.In circular mode the controller continuously writes data in to the memory until to be disabled by the software. The data are transferred in the circular buffer in the memory, which is defined by the RFMON_ADDR_REG and the RFMON_LEN_REG registers. The disabling of the controller is realized by writing the RFMON_PACK_EN with 0.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFMON_PACK_EN</name>
	<description>Starts the capturing of the data from the test bus
0 : There is no capturing of data.
1 : The controller captures data.
Should be written with 1 in order to start the acquisition of data.
If the controller is not in circular mode (RFMON_CIRC_EN = 0) and after capturing a predefined number of words (RFMON_LEN), this bit will be auto cleared.
In circular mode (RFMON_CIRC_EN = 1) the RFMON_PACK_EN remains 1 until to be cleared by the software.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RFMON_LEN_REG</name>
	<description>Data length register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_LEN</name>
	<description>The number of words (minus one) that should be captured.</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RFMON_STAT_REG</name>
	<description>Status register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_OFLOW_STK</name>
	<description>Indicates that during the transfer of the data, at least one overflow has detected to the fifo.
0 : The transfer completed without overflows.
1 : At least one overflow occured in the fifo.
Write 1 to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFMON_ACTIVE</name>
	<description>Indicates the state of the controller.
0 : The controller is idle.
1 : The controller is active. The capturing process and/or the dma activity is in progress.
The controller will be activated (RFMON_ACTIVE == 1), when RFMON_PACK_EN will be written with 1. Will return to inactive state, after the end of the capturing process (RFMON_PACK_EN==0) and the completion of the transfer of all of the data to the memory. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RTC</name>
	<version>1.0</version>
	<description>RTC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50004100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>52</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RTC_ALARM_ENABLE_REG</name>
	<description>RTC Alarm Enable Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RTC_ALARM_MNTH_EN</name>
	<description>Alarm on month enable. Enable to trigger alarm when data specified in Calendar Alarm Register (M_T and M_U) has been reached.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_DATE_EN</name>
	<description>Alarm on date enable. Enable to trigger alarm when data specified in Calendar Alarm Register (D_T and D_U) has been reached.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_HOUR_EN</name>
	<description>Alarm on hour enable. Enable to trigger alarm when data specified in Time Alarm Register (PM, HR_T and HR_U) has been reached.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_MIN_EN</name>
	<description>Alarm on minute enable. Enable to trigger alarm when data specified in Time Alarm Register (M_T and M_U) has been reached.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_SEC_EN</name>
	<description>Alarm on second enable. Enable to trigger alarm when data specified in Time Alarm Register (S_T and S_U) has been reached.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_HOS_EN</name>
	<description>Alarm on hundredths of a second enable. Enable to trigger alarm when data specified in Time Alarm Register (H_T and H_U) has been reached.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CALENDAR_ALARM_REG</name>
	<description>RTC Calendar Alram Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_CAL_D_T</name>
	<description>Date tens. Represented in BCD digit (0-3).</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_U</name>
	<description>Date units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_T</name>
	<description>Month tens. Represented in BCD digit (0-1).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_U</name>
	<description>Month units. Represented in BCD digit (0-9).</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CALENDAR_REG</name>
	<description>RTC Calendar Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x2000010f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_CAL_CH</name>
	<description>The value in this register has altered since last read. Read and clear</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_C_T</name>
	<description>Century tens. Represented in BCD digit (1-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_C_U</name>
	<description>Century units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_Y_T</name>
	<description>Year tens. Represented in BCD digit (0-9).</description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_Y_U</name>
	<description>Year units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_T</name>
	<description>Date tens. Represented in BCD digit (0-3).</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_U</name>
	<description>Date units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_T</name>
	<description>Month tens. Represented in BCD digit (0-1).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_U</name>
	<description>Month units. Represented in BCD digit (0-9).</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DAY</name>
	<description>Day of the week (arbitrary) units. Represented in BCD digit (0-7).</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CONTROL_REG</name>
	<description>RTC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>RTC_CAL_DISABLE</name>
	<description>When this field is set high the RTC stops incrementing the calendar value.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_DISABLE</name>
	<description>When this field is set high the RTC stops incrementing the time value.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_EVENT_FLAGS_REG</name>
	<description>RTC Event Flags Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_EVENT_ALRM</name>
	<description>Alarm event flag. Indicate that alarm event occurred since the last reset.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_MNTH</name>
	<description>Month rolls over event flag. Indicate that month rolls over event occurred since the last reset.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_DATE</name>
	<description>Date rolls over event flag. Indicate that date rolls over event occurred since the last reset.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_HOUR</name>
	<description>Hour rolls over event flag. Indicate that hour rolls over event occurred since the last reset.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_MIN</name>
	<description>Minute rolls over event flag. Indicate that minute rolls over event occurred since the last reset.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_SEC</name>
	<description>Second rolls over event flag. Indicate that second rolls over event occurred since the last reset.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_HOS</name>
	<description>Hundredths of a second event flag. Indicate that hundredths of a second rolls over event occurred since the last reset.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_HOUR_MODE_REG</name>
	<description>RTC Hour Mode Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RTC_HMS</name>
	<description>When this field is set high the RTC operates in 12 hour clock mode; otherwise, times are in 24 hour clock format.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_DISABLE_REG</name>
	<description>RTC Interrupt Disable Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_DIS</name>
	<description>Interrupt on alarm disable. Disable to issue the interrupt when alarm event occurred.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MNTH_INT_DIS</name>
	<description>Interrupt on month disable. Disable to issue the interrupt when month event occurred.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_DATE_INT_DIS</name>
	<description>Interrupt on date disable. Disable to issue the interrupt when date event occurred.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOUR_INT_DIS</name>
	<description>IInterrupt on hour disable. Disable to issue the interrupt when hour event occurred.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MIN_INT_DIS</name>
	<description>Interrupt on minute disable. Disable to issue the interrupt when minute event occurred.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_SEC_INT_DIS</name>
	<description>Interrupt on second disable. Disable to issue the interrupt when second event occurred.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOS_INT_DIS</name>
	<description>Interrupt on hundredths of a second disable. Disable to issue the interrupt when hundredths of a second event occurred.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_ENABLE_REG</name>
	<description>RTC Interrupt Enable Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_EN</name>
	<description>Interrupt on alarm enable. Enable to issue the interrupt when alarm event occurred.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MNTH_INT_EN</name>
	<description>Interrupt on month enable. Enable to issue the interrupt when month event occurred.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_DATE_INT_EN</name>
	<description>Interrupt on date enable. Enable to issue the interrupt when date event occurred.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOUR_INT_EN</name>
	<description>Interrupt on hour enable. Enable to issue the interrupt when hour event occurred.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MIN_INT_EN</name>
	<description>Interrupt on minute enable. Enable to issue the interrupt when minute event occurred.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_SEC_INT_EN</name>
	<description>Interrupt on second enable. Enable to issue the interrupt when second event occurred.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOS_INT_EN</name>
	<description>Interrupt on hundredths of a second enable. Enable to issue the interrupt when hundredths of a second event occurred.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_MASK_REG</name>
	<description>RTC Interrupt Mask Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_MSK</name>
	<description>Mask alarm interrupt. It can be cleared (set) by setting corresponding bit (ALRM) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_MNTH_INT_MSK</name>
	<description>IMask month interrupt. It can be cleared (set) by setting corresponding bit (MNTH) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_DATE_INT_MSK</name>
	<description>Mask date interrupt. It can be cleared (set) by setting corresponding bit (DATE) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_HOUR_INT_MSK</name>
	<description>IMask hour interrupt. It can be cleared (set) by setting corresponding bit (HOUR) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_MIN_INT_MSK</name>
	<description>IMask minute interrupt. It can be cleared (set) by setting corresponding bit (MIN) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_SEC_INT_MSK</name>
	<description>IMask second interrupt. It can be cleared (set) by setting corresponding bit (SEC) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_HOS_INT_MSK</name>
	<description>Mask hundredths of a second interrupt. It can be cleared (set) by setting corresponding bit (HOS) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_KEEP_RTC_REG</name>
	<description>RTC Keep RTC Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RTC_KEEP</name>
	<description>Keep RTC. When high, the time and calendar registers and any other registers which directly affect or are affected by the time and calendar registers are NOT reset when software reset is applied. When low, the software reset will reset every register except the keep RTC and control registers.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_STATUS_REG</name>
	<description>RTC Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>RTC_VALID_CAL_ALM</name>
	<description>Valid Calendar Alarm. If cleared then indicates that invalid entry occurred when writing to Calendar Alarm Register.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_TIME_ALM</name>
	<description>Valid Time Alarm. If cleared then indicates that invalid entry occurred when writing to Time Alarm Register.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_CAL</name>
	<description>Valid Calendar. If cleared then indicates that invalid entry occurred when writing to Calendar Register.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_TIME</name>
	<description>Valid Time. If cleared then indicates that invalid entry occurred when writing to Time Register.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_TIME_ALARM_REG</name>
	<description>RTC Time Alarm Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_TIME_PM</name>
	<description>In 12 hour clock mode, indicates PM when set.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_T</name>
	<description>Hours tens. Represented in BCD digit (0-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_U</name>
	<description>Hours units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_T</name>
	<description>Minutes tens. Represented in BCD digit (0-5).</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_U</name>
	<description>Minutes units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_T</name>
	<description>Seconds tens. Represented in BCD digit (0-9).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_U</name>
	<description>Seconds units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_T</name>
	<description>Hundredths of a second tens. Represented in BCD digit (0-9).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_U</name>
	<description>Hundredths of a second units. Represented in BCD digit (0-9).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_TIME_REG</name>
	<description>RTC Time Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_TIME_CH</name>
	<description>The value in this register has altered since last read. Read and clear.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_PM</name>
	<description>In 12 hour clock mode, indicates PM when set.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_T</name>
	<description>Hours tens. Represented in BCD digit (0-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_U</name>
	<description>Hours units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_T</name>
	<description>Minutes tens. Represented in BCD digit (0-5).</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_U</name>
	<description>Minutes units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_T</name>
	<description>Seconds tens. Represented in BCD digit (0-9).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_U</name>
	<description>Seconds units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_T</name>
	<description>Hundredths of a second tens. Represented in BCD digit (0-9).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_U</name>
	<description>Hundredths of a second units. Represented in BCD digit (0-9).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SPI</name>
	<version>1.0</version>
	<description>SPI registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>50</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>SPI_CLOCK_REG</name>
	<description>Spi clock register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_MASTER_CLK_MODE</name>
	<description>Should be always 1</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK_DIV</name>
	<description>Applicable only in master mode
Defines the spi clock frequency in master only mode
SPI_CLK = module_clk / 2*(SPI_CLK_DIV+1) when SPI_CLK_DIV not 0x7F
if SPI_CLK_DIV=0x7F then SPI_CLK=module_clk</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CONFIG_REG</name>
	<description>Spi control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_SLAVE_EN</name>
	<description>0 = SPI module master mode
1 = SPI module slave mode
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_WORD_LENGTH</name>
	<description>Define the spi word length = 1+ SPI_WORD_LENGTH (range 4 to 32)</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_MODE</name>
	<description>Define the spi mode (CPOL, CPHA)
0 = new data on falling, capture on rising, clk low in idle state
1 = new data on rising, capture on falling, Clk low in idle state
2 = new data on rising, capture on falling, Clk high in idle state
3 = new data on falling, capture on rising Clk high in idle state
</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CS_CONFIG_REG</name>
	<description>Spi cs configuration register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>SPI_CS_SELECT</name>
	<description>Control the cs output in master mode
0 = none slave device selected
1 = selected slave device connected to GPIO with FUNC_MODE=SPI_CS0
2 = selected slave device connected to GPIO with FUNC_MODE=SPI_CS1
4 = selected slave device connected to GPIO with FUNC_MODE=GPIO</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CTRL_REG</name>
	<description>Spi control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_SWAP_BYTES</name>
	<description>0 = normal operation
1 = LSB and MSB are swaped in APB interface
In case of 8bit spi interface, DMA/SPI can be configured in 16bit mode to off load the bus. Enabling SPI_SWAP_BYTES bytes will read/wrte correctly</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CAPTURE_AT_NEXT_EDGE</name>
	<description>0 = SPI captures data at correct clock edge
1 = SPI captures data at next clock edge. (only for Master mode and high clock)</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_FIFO_RESET</name>
	<description>0 = Fifo normal operation
1 = Fifo in reset state
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DMA_RX_EN</name>
	<description>applicable only when SPI_RX_EN=1
0 = No DMA request for RX
1 = DMA request when SPI_STATUS_RX_FULL='1'
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DMA_TX_EN</name>
	<description>applicable only when SPI_TX_EN=1
0 = No DMA request for TX
1 = DMA request when SPI_STATUS_TX_EMPTY='1'
</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_RX_EN</name>
	<description>0 = RX path is disabled
1 = RX path is enabled
Note: if master clk async or spi mode=1 or spi mode=3 readonly is not supported</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_TX_EN</name>
	<description>0 = TX path is disabled
1 = TX path is enabled
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_EN</name>
	<description>0 = SPI module is disable
1 = SPI module is enable
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_CONFIG_REG</name>
	<description>Spi fifo configuration register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_RX_TL</name>
	<description>Receive FIFO threshold level in bytes. Control the level of bytes in fifo that triggers the RX_FULL interrupt. IRQ is occurred when fifo level is more or equal to SPI_RX_TL+1. Fifo level is from 0 to 4</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_TX_TL</name>
	<description>Transmit FIFO threshold level in bytes. Control the level of bytes in fifo that triggers the TX_EMPTY interrupt. IRQ is occurred when fifo level is less or equal to SPI_TX_TL. Fifo level is from 0 to 4</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_HIGH_REG</name>
	<description>Spi TX/RX High 16bit word</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_FIFO_HIGH</name>
	<description>RX/TX fifo data. 16 MSb when spi word is larger than 16bits
This register has to be written before the SPI_FIFO_WRITE_REG
This register has to be read after the SPI_FIFO_READ_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_READ_REG</name>
	<description>Spi RX fifo read register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_FIFO_READ</name>
	<description>Read from RX fifo. Read access is permit only if SPI_RX_FIFO_EMPTY=0. Returns the 16 LSb</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_STATUS_REG</name>
	<description>SPI RX/TX fifo status register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_TRANSACTION_ACTIVE</name>
	<description>In master mode
0 = spi transaction is inactive
1 = spi transaction is active</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_OVFL</name>
	<description>When 1, receive data is not written to fifo because fifo was full and interrupt is generated. It clears with SPI_CTRL_REG.SPI_FIFO_RESET
</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_STATUS_TX_FULL</name>
	<description>0 = TX fifo is not full
1 = TX fifo is full
</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_STATUS_RX_EMPTY</name>
	<description>0 = RX fifo is not empty
1 = RX fifo is empty
</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_TX_FIFO_LEVEL</name>
	<description>Gives the number of bytes in TX fifo</description>
	<bitRange>[11:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_LEVEL</name>
	<description>Gives the number of bytes in RX fifo</description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_WRITE_REG</name>
	<description>Spi TX fifo wtite register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_FIFO_WRITE</name>
	<description>Write to TX fifo. Write access is permit only if SPI_TX_FIFO_FULL is 0</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SPI_IRQ_MASK_REG</name>
	<description>Spi interrupt mask register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>SPI_IRQ_MASK_RX_FULL</name>
	<description>0 = FIFO RX full irq is masked
1 = FIFO RX full irq is enabled
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_IRQ_MASK_TX_EMPTY</name>
	<description>0 = FIFO TX empty irq is masked
1 = FIFO TX empy irq is enabled
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_STATUS_REG</name>
	<description>Spi status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>SPI_STATUS_RX_FULL</name>
	<description>Auto clear
0 = RX fifo level is less than SPI_RX_TL+1
1 = RX fifo level is more or equal to SPI_RX_TL+1
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_STATUS_TX_EMPTY</name>
	<description>Auto clear
0 = TX fifo level is larger than SPI_TX_TL
1 = TX fifo level is less or equal to SPI_TX_TL
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SPI_TXBUFFER_FORCE_H_REG</name>
	<description>SPI TX buffer force high value</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_TXBUFFER_FORCE_H</name>
	<description>Write directly the tx buffer (2 MSB). It must to be used only in slave mode.
This register has to be written before the SPI_FIFO_WRITE_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SPI_TXBUFFER_FORCE_L_REG</name>
	<description>SPI TX buffer force low value</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_TXBUFFER_FORCE_L</name>
	<description>Write directly the tx buffer (2 LSB). It must to be used only in slave mode</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SYS_WDOG</name>
	<version>1.0</version>
	<description>SYS_WDOG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>4</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>WATCHDOG_CTRL_REG</name>
	<description>Watchdog control register.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>NMI_RST</name>
	<description>0 = Watchdog timer generates NMI at value 0, and WDOG (SYS) reset at &lt;=-16. Timer can be frozen /resumed using
SET_FREEZE_REG[FRZ_WDOG]/
RESET_FREEZE_REG[FRZ_WDOG].
1 = Watchdog timer generates a WDOG (SYS) reset at value 0 and can not be frozen by Software.
Note that this bit can only be set to 1 by SW and only be reset with a WDOG (SYS) reset or SW reset.
The watchdog is always frozen when the Cortex-M0 is halted in DEBUG State. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WATCHDOG_REG</name>
	<description>Watchdog timer register.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WDOG_WEN</name>
	<description>0000.000 = Write enable for Watchdog timer
else Write disable. This filter prevents unintentional presetting the watchdog with a SW run-away. </description>
	<bitRange>[15:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WDOG_VAL_NEG</name>
	<description>0 = Watchdog timer value is positive.
1 = Watchdog timer value is negative. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WDOG_VAL</name>
	<description>Write: Watchdog timer reload value. Note that all bits 15-9 must be 0 to reload this register.
Read: Actual Watchdog timer value. Decremented by 1 every 10.24 msec. Bit 8 indicates a negative counter value. 2, 1, 0, 1FF16, 1FE16 etc. An NMI or WDOG (SYS) reset is generated under the following conditions:
If WATCHDOG_CTRL_REG[NMI_RST] = 0 then
    If WDOG_VAL = 0 -&gt; NMI (Non Maskable Interrupt)
    if WDOG_VAL = 1F016 -&gt; WDOG reset -&gt; reload FF16
If WATCHDOG_CTRL_REG[NMI_RST] = 1 then
    if WDOG_VAL &lt;= 0 -&gt; WDOG reset -&gt; reload FF16 </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER0</name>
	<version>1.0</version>
	<description>TIMER0 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>36</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>PWM2_END_CYCLE</name>
	<description>Defines end Cycle for PWM2</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM2_START_CYCLE</name>
	<description>Defines start Cycle for PWM2</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM3_END_CYCLE</name>
	<description>Defines end Cycle for PWM3</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM3_START_CYCLE</name>
	<description>Defines start Cycle for PWM3</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM4_END_CYCLE</name>
	<description>Defines end Cycle for PWM4</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM4_START_CYCLE</name>
	<description>Defines start Cycle for PWM4</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM5_END_CYCLE</name>
	<description>Defines end Cycle for PWM5</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM5_START_CYCLE</name>
	<description>Defines start Cycle for PWM5</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM6_END_CYCLE</name>
	<description>Defines end Cycle for PWM6</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM6_START_CYCLE</name>
	<description>Defines start Cycle for PWM6</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM7_END_CYCLE</name>
	<description>Defines end Cycle for PWM7</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM7_START_CYCLE</name>
	<description>Defines start Cycle for PWM7</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_CTRL_REG</name>
	<description>Timer0 control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PWM_MODE</name>
	<description>0 = PWM signals are '1' during high time.
1 = PWM signals send out the (fast) clock divided by 2 during high time. So it will be in the range of 1 to 8 MHz. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM0_CLK_DIV</name>
	<description>1 = Timer0 uses selected clock frequency as is.
0 = Timer0 uses selected clock frequency divided by 10.
Note that this applies only to the ON-counter.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM0_CLK_SEL</name>
	<description>1 = Timer0 uses 16, 8, 4 or 2 MHz (fast) clock frequency.
0 = Timer0 uses LP clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM0_CTRL</name>
	<description>0 = Timer0 is off and in reset state.
1 = Timer0 is running. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_ON_REG</name>
	<description>Timer0 on control register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIM0_ON</name>
	<description>Timer0 On reload value:
If read the actual counter value ON_CNTer is returned </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_RELOAD_M_REG</name>
	<description>16 bits reload value for Timer0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIM0_M</name>
	<description>Timer0 'high' reload valueIf read the actual counter value T0_CNTer is returned </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_RELOAD_N_REG</name>
	<description>16 bits reload value for Timer0</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIM0_N</name>
	<description>Timer0 'low' reload value:
If read the actual counter value T0_CNTer is returned </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TRIPLE_PWM_CTRL_REG</name>
	<description>PWM 2,3,4,5,6,7 Control</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>TRIPLE_PWM_CLK_SEL</name>
	<description>1 = Timer2 uses 16, 8, 4 or 2 MHz (fast) clock frequency.
0 = Timer2 uses LP clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HW_PAUSE_EN</name>
	<description>'1' = HW can pause PWM 2,3,4,5,6,7 </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_PAUSE_EN</name>
	<description>'1' = PWM 2 3 4 5 6 7 are paused </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIPLE_PWM_ENABLE</name>
	<description>'1' = enable PWM 2 3 4 5 6 7</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TRIPLE_PWM_FREQUENCY</name>
	<description>Frequency for PWM 2,3,4,5,6 and 7</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>PWM_FREQ</name>
	<description>Defines the frequeancy of PWM 2,3,4,5,,6 and 7. pwm freq = module Frequency / (value+1)
module frequency is the LP_CLK when TRIPLE_PWM_CLK_SEL=0 else is the sys_clk divided by TMR_DIV</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER1</name>
	<version>1.0</version>
	<description>TIMER1 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50004000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>24</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>TIMER1_CAPCNT1_VALUE_REG</name>
	<description>Timer1 value for event on GPIO1</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x003fffff</resetMask>
	<fields><field>
	<name>TIMER1_CAPCNT1_RTC_HIGH</name>
	<description>In Counter mode : Not used
In Capture mode: Gives the RTC time stamp (high part) when an IN1 event was occurred </description>
	<bitRange>[21:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_CAPCNT1_VALUE</name>
	<description>In Counter mode : Gives the number of timer clock cycles minus 1 which was measured during TIMER1_IN1_PERIOD_MAX periods of IN1
In Capture mode (TIMER1_IN1_STAMP_TYPE=0) : Gives the Counter value when an IN1 event was occurred
In Capture mode (TIMER1_IN1_STAMP_TYPE=1) : Gives the RTC time stamp (low part) when an IN1 event was occurred </description>
	<bitRange>[10:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER1_CAPCNT2_VALUE_REG</name>
	<description>Timer1 value for event on GPIO2</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x003fffff</resetMask>
	<fields><field>
	<name>TIMER1_CAPCNT2_RTC_HIGH</name>
	<description>In Counter mode : Not used
In Capture mode: Gives the RTC time stamp (high part) when an IN2 event was occurred </description>
	<bitRange>[21:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_CAPCNT2_VALUE</name>
	<description>In Counter mode : Gives the number of timer clock cycles minus 1 which was measured during TIMER1_IN2_PERIOD_MAX periods of IN2
In Capture mode (TIMER1_IN2_STAMP_TYPE=0) : Gives the Counter value when an IN2 event was occurred
In Capture mode (TIMER1_IN2_STAMP_TYPE=1) : Gives the RTC time stamp (low part) when an IN2 event was occurred </description>
	<bitRange>[10:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER1_CAPTURE_REG</name>
	<description>Timer1 Capture control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0fffffff</resetMask>
	<fields><field>
	<name>TIMER1_IN2_STAMP_TYPE</name>
	<description>0 = On each event store the counter value
1 = On each event store the RTC time stamp</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN2_PERIOD_MAX</name>
	<description>Gives the number of periods +1 of IN2, in which module counts</description>
	<bitRange>[26:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN2_IRQ_EN</name>
	<description>1 = Interrupt is generated when capture is occurred or was counted TIMER1_IN2_PERIOD_MAX
0 = Interrupt is masked</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN2_COUNT_EN</name>
	<description>0 = Capture mode
1 = Count mode</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN2_EVENT_FALL_EN</name>
	<description>0 = Rising edge event
1 = Falling edge event
it should be written when TIMER1_GPIO2_CONF=0 to prevent false events</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_GPIO2_CONF</name>
	<description>0,13,14,15 = IN2 is not used
1..12 = Defines the P0 pin (0..11) module will use as IN2</description>
	<bitRange>[17:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_STAMP_TYPE</name>
	<description>0 = On each event store the counter value
1 = On each event store the RTC time stamp</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_PERIOD_MAX</name>
	<description>Gives the number of periods +1 of IN1, in which module counts</description>
	<bitRange>[12:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_IRQ_EN</name>
	<description>1 = Interrupt is generated when capture is occurred or was counted TIMER1_IN1_PERIOD_MAX
0 = Interrupt is masked</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_COUNT_EN</name>
	<description>0 = Capture mode
1 = Count mode</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_EVENT_FALL_EN</name>
	<description>0 = Rising edge event
1 = Falling edge event
it should be written when TIMER1_GPIO1_CONF=0 to prevent false events</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_GPIO1_CONF</name>
	<description>0,13,14,15 = IN1 is not used
1..12 = Defines the P0 pin (0..11) module will use as IN1</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER1_CLR_EVENT_REG</name>
	<description>Clear event register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>TIMER1_CLR_IN2_EVENT</name>
	<description>Write 1 to clear the TIMER1_IN2_EVENT and TIMER1_IN2_OVRFLW</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_CLR_IN1_EVENT</name>
	<description>Write 1 to clear the TIMER1_IN1_EVENT and TIMER1_IN1_OVRFLW</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_CLR_TIMER_EVENT</name>
	<description>Write 1 to clear the TIMER1_TIMER_EVENT</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER1_CTRL_REG</name>
	<description>Timer1 control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>TIMER1_CLK_EN</name>
	<description>0 = timer1 clock is disabled
1 = timer1 clock is enabled</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_USE_SYS_CLK</name>
	<description>0 = Timer1 use the clock LP clock
1 = Timer1 use the system clock</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_FREE_RUN_MODE_EN</name>
	<description>Applicable when timer counts up
1 = timer1 goes to zero when it reaches the max value.
0 = timer1 goes to zero when it reaches the reload value.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IRQ_EN</name>
	<description>0 = timer1 IRQ masked
1 = timer1 IRQ unmasked</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_COUNT_DOWN_EN</name>
	<description>0 = timer1 counts up
1 = timer1 counts down</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_ENABLE</name>
	<description>0 = Timer1 disabled
1 = Timer1 enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_RELOAD</name>
	<description>Reload or max value in timer mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[10:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER1_STATUS_REG</name>
	<description>Timer1 counter value</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIMER1_IN2_OVRFLW</name>
	<description>1 = New IN2 event occurred while Interrupt was pending.
TIMER1_CAPCNT2_VALUE_REG gives the time stamp of the first event.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_IN1_OVRFLW</name>
	<description>1 = New IN1 event occurred while Interrupt was pending.
TIMER1_CAPCNT1_VALUE_REG gives the time stamp of the first event.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_IN2_EVENT</name>
	<description>1 = Pending Capture 2 interrupt. It has be clear writing 1 to TIMER1_CLR_IN2_EVENT</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_IN1_EVENT</name>
	<description>1 = Pending Capture 1 interrupt. It has be clear writing 1 to TIMER1_CLR_IN1_EVENT</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_TIMER_EVENT</name>
	<description>1 = Pending Timer interrupt. it has be clear writing 1' to TIMER1_CLR_TIMER_EVENT</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[10:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART</name>
	<version>1.0</version>
	<description>UART registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>UART_CTR_HIGH_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fe</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004457</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000110</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART_FAR_REG</name>
	<description>FIFO Access Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>UART_FAR</name>
	<description>Description: Writes will have no effect when FIFO_ACCESS == No, always readable. This register is use to enable a FIFO access mode for testing, so that the receive FIFO can be written by the master and the transmit FIFO can be read by the master when FIFO's are implemented and enabled. When FIFO's are not implemented or not enabled it allows the RBR to be written by the master and the THR to be read by the master. 0 = FIFO access mode disabled 1 = FIFO access mode enabled Note, that when the FIFO access mode is enabled/disabled, the control portion of the receive FIFO and transmit FIFO is reset and the FIFO's are treated as empty.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are implemented and not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IER_DLH_REG</name>
	<description>Interrupt Enable Register/Divisor Latch High</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PTIME_dlh7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled. 
Divisor Latch (High): DLH7, Bit 7 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>dlh6_4</name>
	<description>Divisor Latch (High): DLH6 to DLH4, Bits 6 to 4 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set, otherwise, this field is reserved. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_dlh3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH3, Bit 3 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_dhl2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH2, Bit 2 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_dlh1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): DLH1, Bit 1 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_dlh0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): DLH0, Bit 0 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_FIFOSE_RT</name>
	<description>On read
FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled.
On write
RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_TET</name>
	<description>On read
reserved
On Write
TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full </description>
	<bitRange>[5:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_IID3_DMAM</name>
	<description>On Read (Bit3)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1 </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID2_XFIFOR</name>
	<description>On Read (Bit2)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID1_RFIFOE</name>
	<description>On Read (Bit1)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID0_FIFOE</name>
	<description>On Read (Bit0)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit. Writeable only when UART is not busy (USR[0] is zero).
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. If active (MCR[6] set to one) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver and the sir_out_n line is forced low. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.Writeable only when UART is not busy (USR[0] is zero).
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.Writeable only when UART is not busy (USR[0] is zero).
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
If in infrared mode (SIR_MODE == Enabled), it is set whenever the serial input, sir_in, is continuously pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop bits. A break condition on serial input causes one and only one character, consisting of all zeros, to be received by the UART.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_AFCE</name>
	<description>Auto Flow Control Enable.
Writeable only when AFCE_MODE == Enabled, always readable. When FIFOs are enabled and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow Control features are enabled as described in &quot;Auto Flow Control&quot;.
0 = Auto Flow Control Mode disabled
1 = Auto Flow Control Mode enabled </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_RTS</name>
	<description>Request to Send.
This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal is set low by programming MCR[1] (RTS) to a high.In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] set to one) and FIFOs enable (FCR[0] set to one), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). The rts_n signal is de-asserted when MCR[1] is set low.
Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_MSR_REG</name>
	<description>Modem Status Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_CTS</name>
	<description>Clear to Send.
This is used to indicate the current state of the modem control line cts_n. This bit is the complement of cts_n. When the Clear to Send input (cts_n) is asserted it is an indication that the modem or data set is ready to exchange data with the UART Ctrl.
0 = cts_n input is de-asserted (logic 1)
1 = cts_n input is asserted (logic 0)
In Loopback Mode (MCR[4] = 1), CTS is the same as MCR[1] (RTS). </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register/Transmit Holding Register/Divisor Latch Low</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, 16 number of characters of data may be written to the THR before the FIFO is full. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the Divisor Latch is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.
For the Divisor Latch (High) bits, see register UART_IER_DLH_REG.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_RFL_REG</name>
	<description>Receive FIFO Level</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.
If SIR_MODE active (MCR[6] = 1) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART_SRTS_REG</name>
	<description>Shadow Request to Send</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_REQUEST_TO_SEND</name>
	<description>Shadow Request to Send.
This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the burden of having to
performing a read-modify-write on the MCR. This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART Ctrl is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] = 0), the rts_n signal is set low by programming MCR[1] (RTS) to a high.
In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] = 1) and FIFOs enable (FCR[0] = 1), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold).
Note that in Loopback mode (MCR[4] = 1), the rts_n output is held inactive-high while the value of this location is internally looped back to an input. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_UCV_HIGH_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000fa</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003331</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000352a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_USR_REG</name>
	<description>UART Status Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive. 0 - DW_apb_uart is idle or inactive 1 - DW_apb_uart is busy (actively transferring data) Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the DW_apb_uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the DW_apb_uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART2</name>
	<version>1.0</version>
	<description>UART2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>UART2_CTR_HIGH_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fe</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004457</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000110</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART2_FAR_REG</name>
	<description>FIFO Access Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>UART_FAR</name>
	<description>Description: Writes will have no effect when FIFO_ACCESS == No, always readable. This register is use to enable a FIFO access mode for testing, so that the receive FIFO can be written by the master and the transmit FIFO can be read by the master when FIFO's are implemented and enabled. When FIFO's are not implemented or not enabled it allows the RBR to be written by the master and the THR to be read by the master. 0 = FIFO access mode disabled 1 = FIFO access mode enabled Note, that when the FIFO access mode is enabled/disabled, the control portion of the receive FIFO and transmit FIFO is reset and the FIFO's are treated as empty.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are implemented and not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IER_DLH_REG</name>
	<description>Interrupt Enable Register/Divisor Latch High</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PTIME_dlh7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled. 
Divisor Latch (High): DLH7, Bit 7 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>dlh6_4</name>
	<description>Divisor Latch (High): DLH6 to DLH4, Bits 6 to 4 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set, otherwise, this field is reserved. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_dlh3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH3, Bit 3 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_dhl2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH2, Bit 2 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_dlh1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): DLH1, Bit 1 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_dlh0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): DLH0, Bit 0 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_FIFOSE_RT</name>
	<description>On read
FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled.
On write
RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_TET</name>
	<description>On read
reserved
On Write
TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full </description>
	<bitRange>[5:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_IID3_DMAM</name>
	<description>On Read (Bit3)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1 </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID2_XFIFOR</name>
	<description>On Read (Bit2)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID1_RFIFOE</name>
	<description>On Read (Bit1)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID0_FIFOE</name>
	<description>On Read (Bit0)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.Writeable only when UART is not busy (USR[0] is zero).
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. If active (MCR[6] set to one) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver and the sir_out_n line is forced low. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits. Writeable only when UART is not busy (USR[0] is zero).
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.Writeable only when UART is not busy (USR[0] is zero).
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
If in infrared mode (SIR_MODE == Enabled), it is set whenever the serial input, sir_in, is continuously pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop bits. A break condition on serial input causes one and only one character, consisting of all zeros, to be received by the UART.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register/Transmit Holding Register/Divisor Latch Low</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, 16 number of characters of data may be written to the THR before the FIFO is full. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the Divisor Latch is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.
For the Divisor Latch (High) bits, see register UART_IER_DLH_REG.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_RFL_REG</name>
	<description>Receive FIFO Level</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.
If SIR_MODE active (MCR[6] = 1) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART2_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_UCV_HIGH_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000fa</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003331</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000352a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_USR_REG</name>
	<description>UART Status Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive. 0 - DW_apb_uart is idle or inactive 1 - DW_apb_uart is busy (actively transferring data) Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the DW_apb_uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the DW_apb_uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>WKUP</name>
	<version>1.0</version>
	<description>WKUP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>WKUP2_POL_GPIO_REG</name>
	<description>Select the sensitivity polarity for each P1 input</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>WKUP2_POL_GPIO</name>
	<description>0 = enabled input P0x will increment the event counter if that input goes high
1 = enabled input P0x will increment the event counter if that input goes low</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP2_SELECT_GPIO_REG</name>
	<description>Select which inputs from P1 port can trigger wkup counter</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>WKUP2_SELECT_GPIO</name>
	<description>0 = input P0x is not enabled for wakeup event counter
1 = input P0x is enabled for wakeup event counter</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_COMPARE_REG</name>
	<description>Number of events before wakeup interrupt</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>WKUP_COMPARE</name>
	<description>Defines the number of events -1 that have to be counted before the wakeup interrupt will be given. value 0 means one event.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_COUNTER_REG</name>
	<description>Actual number of events of the wakeup counter</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>EVENT2_VALUE</name>
	<description>This value represents the number of events that have been counted so far. It will be reset by resetting the interrupt. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENT_VALUE</name>
	<description>This value represents the number of events that have been counted so far. It will be reset by resetting the interrupt. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>WKUP_CTRL_REG</name>
	<description>Control register for the wakeup counter</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>WKUP2_ENABLE_IRQ</name>
	<description>0 = no interrupt will be generated
1 = if the event counter2 reaches the value set by WKUP_COMPARE_REG an IRQ will be generated </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_ENABLE_IRQ</name>
	<description>0 = no interrupt will be generated
1 = if the event counter reaches the value set by WKUP_COMPARE_REG an IRQ will be generated </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_SFT_KEYHIT</name>
	<description>0 = no effect
1 = emulate key hit. The event counter and counter2 will increment by 1 (after debouncing if enabled). First make this bit 0 before any new key hit can be sensed. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_DEB_VALUE</name>
	<description>Keyboard debounce time (N*1 ms with N = 1 to 63).
0x0: no debouncing
0x1 to 0x3F: 1 ms to 63 ms debounce time</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_IRQ_STATUS_REG</name>
	<description>Reset wakeup interrupt</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>WKUP2_CNTR_RST</name>
	<description>writing 1 will reset the event2 counter</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WKUP_CNTR_RST</name>
	<description>writing 1 will reset the event counter</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WKUP2_IRQ_STATUS</name>
	<description>Gives 1 when there is a wkup2 pending IRQ. Writing 1 will reset the interrupt. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_IRQ_STATUS</name>
	<description>Gives 1 when there is a wkup pending IRQ. Writing 1 will reset the interrupt. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_GPIO_REG</name>
	<description>Select the sensitivity polarity for each P0 input</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>WKUP_POL_GPIO</name>
	<description>0 = enabled input P0x will increment the event counter if that input goes high
1 = enabled input P0x will increment the event counter if that input goes low</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_GPIO_REG</name>
	<description>Select which inputs from P0 port can trigger wkup counter</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>WKUP_SELECT_GPIO</name>
	<description>0 = input P0x is not enabled for wakeup event counter
1 = input P0x is enabled for wakeup event counter</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral></peripherals>
</device>
